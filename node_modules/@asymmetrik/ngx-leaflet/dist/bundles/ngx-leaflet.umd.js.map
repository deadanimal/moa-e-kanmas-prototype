{"version":3,"sources":["/Users/pnsb/Desktop/MOA - E-KANMAS/node_modules/@asymmetrik/ngx-leaflet/dist/bundles/ngx-leaflet.umd.js"],"names":[],"mappings":"AAAA;;oGAE2E;yEAClB;qDACnB;0BACnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uCAmYoB,AAI5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBACkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4CAyEe,AAIjC;;;;;;;;;;;;;;;;;;oBACuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6CA+EW,AAIlC;;;;;;;;;;;;oBACwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDAgLiB,AAIzC;;;;;;;;;;;;;;;;;;oBAC+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDA6GO,AAItC;;;;;;;;;;;;;;;;;;oBAC4B;;;;;;SAM9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gDAkBiB","file":"ngx-leaflet.umd.js","sourcesContent":["/*! @license @asymmetrik/ngx-leaflet - 7.0.0 - Copyright Asymmetrik, Ltd. 2007-2020 - All Rights Reserved. + */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('leaflet')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'leaflet'], factory) :\n    (global = global || self, factory(global.ngxLeaflet = {}, global.ng.core, global.L));\n}(this, (function (exports, core, leaflet) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n\r\n    function __decorate(decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    }\r\n\r\n    function __metadata(metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    }\n\n    var LeafletUtil = /** @class */ (function () {\n        function LeafletUtil() {\n        }\n        LeafletUtil.mapToArray = function (map) {\n            var toReturn = [];\n            for (var k in map) {\n                if (map.hasOwnProperty(k)) {\n                    toReturn.push(map[k]);\n                }\n            }\n            return toReturn;\n        };\n        LeafletUtil.handleEvent = function (zone, eventEmitter, event) {\n            // Don't want to emit if there are no observers\n            if (0 < eventEmitter.observers.length) {\n                zone.run(function () {\n                    eventEmitter.emit(event);\n                });\n            }\n        };\n        return LeafletUtil;\n    }());\n\n    var LeafletDirective = /** @class */ (function () {\n        function LeafletDirective(element, zone) {\n            this.element = element;\n            this.zone = zone;\n            this.DEFAULT_ZOOM = 1;\n            this.DEFAULT_CENTER = leaflet.latLng(38.907192, -77.036871);\n            this.DEFAULT_FPZ_OPTIONS = {};\n            this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n            this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n            this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n            this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS;\n            // Default configuration\n            this.options = {};\n            // Configure callback function for the map\n            this.mapReady = new core.EventEmitter();\n            this.zoomChange = new core.EventEmitter();\n            this.centerChange = new core.EventEmitter();\n            // Mouse Map Events\n            this.onClick = new core.EventEmitter();\n            this.onDoubleClick = new core.EventEmitter();\n            this.onMouseDown = new core.EventEmitter();\n            this.onMouseUp = new core.EventEmitter();\n            this.onMouseMove = new core.EventEmitter();\n            this.onMouseOver = new core.EventEmitter();\n            this.onMouseOut = new core.EventEmitter();\n            // Map Move Events\n            this.onMapMove = new core.EventEmitter();\n            this.onMapMoveStart = new core.EventEmitter();\n            this.onMapMoveEnd = new core.EventEmitter();\n            // Map Zoom Events\n            this.onMapZoom = new core.EventEmitter();\n            this.onMapZoomStart = new core.EventEmitter();\n            this.onMapZoomEnd = new core.EventEmitter();\n            // Nothing here\n        }\n        LeafletDirective.prototype.ngOnInit = function () {\n            var _this = this;\n            // Create the map outside of angular so the various map events don't trigger change detection\n            this.zone.runOutsideAngular(function () {\n                // Create the map with some reasonable defaults\n                _this.map = leaflet.map(_this.element.nativeElement, _this.options);\n                _this.addMapEventListeners();\n            });\n            // Only setView if there is a center/zoom\n            if (null != this.center && null != this.zoom) {\n                this.setView(this.center, this.zoom);\n            }\n            // Set up all the initial settings\n            if (null != this.fitBounds) {\n                this.setFitBounds(this.fitBounds);\n            }\n            if (null != this.maxBounds) {\n                this.setMaxBounds(this.maxBounds);\n            }\n            if (null != this.minZoom) {\n                this.setMinZoom(this.minZoom);\n            }\n            if (null != this.maxZoom) {\n                this.setMaxZoom(this.maxZoom);\n            }\n            this.doResize();\n            // Fire map ready event\n            this.mapReady.emit(this.map);\n        };\n        LeafletDirective.prototype.ngOnChanges = function (changes) {\n            /*\n             * The following code is to address an issue with our (basic) implementation of\n             * zooming and panning. From our testing, it seems that a pan operation followed\n             * by a zoom operation in the same thread will interfere with eachother. The zoom\n             * operation interrupts/cancels the pan, resulting in a final center point that is\n             * inaccurate. The solution seems to be to either separate them with a timeout or\n              * to collapse them into a setView call.\n             */\n            // Zooming and Panning\n            if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n                this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n            }\n            // Set the zoom level\n            else if (changes['zoom']) {\n                this.setZoom(changes['zoom'].currentValue);\n            }\n            // Set the map center\n            else if (changes['center']) {\n                this.setCenter(changes['center'].currentValue);\n            }\n            // Other options\n            if (changes['fitBounds']) {\n                this.setFitBounds(changes['fitBounds'].currentValue);\n            }\n            if (changes['maxBounds']) {\n                this.setMaxBounds(changes['maxBounds'].currentValue);\n            }\n            if (changes['minZoom']) {\n                this.setMinZoom(changes['minZoom'].currentValue);\n            }\n            if (changes['maxZoom']) {\n                this.setMaxZoom(changes['maxZoom'].currentValue);\n            }\n        };\n        LeafletDirective.prototype.getMap = function () {\n            return this.map;\n        };\n        LeafletDirective.prototype.onResize = function () {\n            this.delayResize();\n        };\n        LeafletDirective.prototype.addMapEventListeners = function () {\n            var _this = this;\n            // Add all the pass-through mouse event handlers\n            this.map.on('click', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onClick, e); });\n            this.map.on('dblclick', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onDoubleClick, e); });\n            this.map.on('mousedown', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMouseDown, e); });\n            this.map.on('mouseup', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMouseUp, e); });\n            this.map.on('mouseover', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMouseOver, e); });\n            this.map.on('mouseout', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMouseOut, e); });\n            this.map.on('mousemove', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMouseMove, e); });\n            this.map.on('zoomstart', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMapZoomStart, e); });\n            this.map.on('zoom', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMapZoom, e); });\n            this.map.on('zoomend', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMapZoomEnd, e); });\n            this.map.on('movestart', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMapMoveStart, e); });\n            this.map.on('move', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMapMove, e); });\n            this.map.on('moveend', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onMapMoveEnd, e); });\n            // Update any things for which we provide output bindings\n            this.map.on('zoomend moveend', function () {\n                var zoom = _this.map.getZoom();\n                if (zoom !== _this.zoom) {\n                    _this.zoom = zoom;\n                    LeafletUtil.handleEvent(_this.zone, _this.zoomChange, zoom);\n                }\n                var center = _this.map.getCenter();\n                if (null != center || null != _this.center) {\n                    if (((null == center || null == _this.center) && center !== _this.center)\n                        || (center.lat !== _this.center.lat || center.lng !== _this.center.lng)) {\n                        _this.center = center;\n                        LeafletUtil.handleEvent(_this.zone, _this.centerChange, center);\n                    }\n                }\n            });\n        };\n        /**\n         * Resize the map to fit it's parent container\n         */\n        LeafletDirective.prototype.doResize = function () {\n            var _this = this;\n            // Run this outside of angular so the map events stay outside of angular\n            this.zone.runOutsideAngular(function () {\n                // Invalidate the map size to trigger it to update itself\n                _this.map.invalidateSize({});\n            });\n        };\n        /**\n         * Manage a delayed resize of the component\n         */\n        LeafletDirective.prototype.delayResize = function () {\n            if (null != this.resizeTimer) {\n                clearTimeout(this.resizeTimer);\n            }\n            this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n        };\n        /**\n         * Set the view (center/zoom) all at once\n         * @param center The new center\n         * @param zoom The new zoom level\n         */\n        LeafletDirective.prototype.setView = function (center, zoom) {\n            if (this.map && null != center && null != zoom) {\n                this.map.setView(center, zoom, this.zoomPanOptions);\n            }\n        };\n        /**\n         * Set the map zoom level\n         * @param zoom the new zoom level for the map\n         */\n        LeafletDirective.prototype.setZoom = function (zoom) {\n            if (this.map && null != zoom) {\n                this.map.setZoom(zoom, this.zoomOptions);\n            }\n        };\n        /**\n         * Set the center of the map\n         * @param center the center point\n         */\n        LeafletDirective.prototype.setCenter = function (center) {\n            if (this.map && null != center) {\n                this.map.panTo(center, this.panOptions);\n            }\n        };\n        /**\n         * Fit the map to the bounds\n         * @param latLngBounds the boundary to set\n         */\n        LeafletDirective.prototype.setFitBounds = function (latLngBounds) {\n            if (this.map && null != latLngBounds) {\n                this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n            }\n        };\n        /**\n         * Set the map's max bounds\n         * @param latLngBounds the boundary to set\n         */\n        LeafletDirective.prototype.setMaxBounds = function (latLngBounds) {\n            if (this.map && null != latLngBounds) {\n                this.map.setMaxBounds(latLngBounds);\n            }\n        };\n        /**\n         * Set the map's min zoom\n         * @param number the new min zoom\n         */\n        LeafletDirective.prototype.setMinZoom = function (zoom) {\n            if (this.map && null != zoom) {\n                this.map.setMinZoom(zoom);\n            }\n        };\n        /**\n         * Set the map's min zoom\n         * @param number the new min zoom\n         */\n        LeafletDirective.prototype.setMaxZoom = function (zoom) {\n            if (this.map && null != zoom) {\n                this.map.setMaxZoom(zoom);\n            }\n        };\n        __decorate([\n            core.Input('leafletFitBoundsOptions'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"fitBoundsOptions\", void 0);\n        __decorate([\n            core.Input('leafletPanOptions'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"panOptions\", void 0);\n        __decorate([\n            core.Input('leafletZoomOptions'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"zoomOptions\", void 0);\n        __decorate([\n            core.Input('leafletZoomPanOptions'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"zoomPanOptions\", void 0);\n        __decorate([\n            core.Input('leafletOptions'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"options\", void 0);\n        __decorate([\n            core.Output('leafletMapReady'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"mapReady\", void 0);\n        __decorate([\n            core.Input('leafletZoom'),\n            __metadata(\"design:type\", Number)\n        ], LeafletDirective.prototype, \"zoom\", void 0);\n        __decorate([\n            core.Output('leafletZoomChange'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"zoomChange\", void 0);\n        __decorate([\n            core.Input('leafletCenter'),\n            __metadata(\"design:type\", leaflet.LatLng)\n        ], LeafletDirective.prototype, \"center\", void 0);\n        __decorate([\n            core.Output('leafletCenterChange'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"centerChange\", void 0);\n        __decorate([\n            core.Input('leafletFitBounds'),\n            __metadata(\"design:type\", leaflet.LatLngBounds)\n        ], LeafletDirective.prototype, \"fitBounds\", void 0);\n        __decorate([\n            core.Input('leafletMaxBounds'),\n            __metadata(\"design:type\", leaflet.LatLngBounds)\n        ], LeafletDirective.prototype, \"maxBounds\", void 0);\n        __decorate([\n            core.Input('leafletMinZoom'),\n            __metadata(\"design:type\", Number)\n        ], LeafletDirective.prototype, \"minZoom\", void 0);\n        __decorate([\n            core.Input('leafletMaxZoom'),\n            __metadata(\"design:type\", Number)\n        ], LeafletDirective.prototype, \"maxZoom\", void 0);\n        __decorate([\n            core.Output('leafletClick'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onClick\", void 0);\n        __decorate([\n            core.Output('leafletDoubleClick'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onDoubleClick\", void 0);\n        __decorate([\n            core.Output('leafletMouseDown'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMouseDown\", void 0);\n        __decorate([\n            core.Output('leafletMouseUp'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMouseUp\", void 0);\n        __decorate([\n            core.Output('leafletMouseMove'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMouseMove\", void 0);\n        __decorate([\n            core.Output('leafletMouseOver'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMouseOver\", void 0);\n        __decorate([\n            core.Output('leafletMouseOut'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMouseOut\", void 0);\n        __decorate([\n            core.Output('leafletMapMove'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMapMove\", void 0);\n        __decorate([\n            core.Output('leafletMapMoveStart'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMapMoveStart\", void 0);\n        __decorate([\n            core.Output('leafletMapMoveEnd'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMapMoveEnd\", void 0);\n        __decorate([\n            core.Output('leafletMapZoom'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMapZoom\", void 0);\n        __decorate([\n            core.Output('leafletMapZoomStart'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMapZoomStart\", void 0);\n        __decorate([\n            core.Output('leafletMapZoomEnd'),\n            __metadata(\"design:type\", Object)\n        ], LeafletDirective.prototype, \"onMapZoomEnd\", void 0);\n        __decorate([\n            core.HostListener('window:resize', []),\n            __metadata(\"design:type\", Function),\n            __metadata(\"design:paramtypes\", []),\n            __metadata(\"design:returntype\", void 0)\n        ], LeafletDirective.prototype, \"onResize\", null);\n        LeafletDirective = __decorate([\n            core.Directive({\n                selector: '[leaflet]'\n            }),\n            __metadata(\"design:paramtypes\", [core.ElementRef, core.NgZone])\n        ], LeafletDirective);\n        return LeafletDirective;\n    }());\n\n    var LeafletDirectiveWrapper = /** @class */ (function () {\n        function LeafletDirectiveWrapper(leafletDirective) {\n            this.leafletDirective = leafletDirective;\n        }\n        LeafletDirectiveWrapper.prototype.init = function () {\n            // Nothing for now\n        };\n        LeafletDirectiveWrapper.prototype.getMap = function () {\n            return this.leafletDirective.getMap();\n        };\n        return LeafletDirectiveWrapper;\n    }());\n\n    /**\n     * Layer directive\n     *\n     * This directive is used to directly control a single map layer. The purpose of this directive is to\n     * be used as part of a child structural directive of the map element.\n     *\n     */\n    var LeafletLayerDirective = /** @class */ (function () {\n        function LeafletLayerDirective(leafletDirective, zone) {\n            this.zone = zone;\n            // Layer Events\n            this.onAdd = new core.EventEmitter();\n            this.onRemove = new core.EventEmitter();\n            this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        }\n        LeafletLayerDirective.prototype.ngOnInit = function () {\n            // Init the map\n            this.leafletDirective.init();\n        };\n        LeafletLayerDirective.prototype.ngOnDestroy = function () {\n            this.layer.remove();\n        };\n        LeafletLayerDirective.prototype.ngOnChanges = function (changes) {\n            var _this = this;\n            if (changes['layer']) {\n                // Update the layer\n                var p_1 = changes['layer'].previousValue;\n                var n_1 = changes['layer'].currentValue;\n                this.zone.runOutsideAngular(function () {\n                    if (null != p_1) {\n                        p_1.remove();\n                    }\n                    if (null != n_1) {\n                        _this.addLayerEventListeners(n_1);\n                        _this.leafletDirective.getMap().addLayer(n_1);\n                    }\n                });\n            }\n        };\n        LeafletLayerDirective.prototype.addLayerEventListeners = function (l) {\n            var _this = this;\n            l.on('add', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onAdd, e); });\n            l.on('remove', function (e) { return LeafletUtil.handleEvent(_this.zone, _this.onRemove, e); });\n        };\n        __decorate([\n            core.Input('leafletLayer'),\n            __metadata(\"design:type\", leaflet.Layer)\n        ], LeafletLayerDirective.prototype, \"layer\", void 0);\n        __decorate([\n            core.Output('leafletLayerAdd'),\n            __metadata(\"design:type\", Object)\n        ], LeafletLayerDirective.prototype, \"onAdd\", void 0);\n        __decorate([\n            core.Output('leafletLayerRemove'),\n            __metadata(\"design:type\", Object)\n        ], LeafletLayerDirective.prototype, \"onRemove\", void 0);\n        LeafletLayerDirective = __decorate([\n            core.Directive({\n                selector: '[leafletLayer]'\n            }),\n            __metadata(\"design:paramtypes\", [LeafletDirective, core.NgZone])\n        ], LeafletLayerDirective);\n        return LeafletLayerDirective;\n    }());\n\n    /**\n     * Layers directive\n     *\n     * This directive is used to directly control map layers. As changes are made to the input array of\n     * layers, the map is synched to the array. As layers are added or removed from the input array, they\n     * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n     * you must change the array instance.\n     *\n     * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n     * immutable array implementation or create a new copy of your array when you make changes, otherwise\n     * this directive won't detect the change. This is by design. It's for performance reasons. Change\n     * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n     * is extremely expensive from a time complexity perspective.\n     *\n     */\n    var LeafletLayersDirective = /** @class */ (function () {\n        function LeafletLayersDirective(leafletDirective, differs, zone) {\n            this.differs = differs;\n            this.zone = zone;\n            this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n            this.layersDiffer = this.differs.find([]).create();\n        }\n        Object.defineProperty(LeafletLayersDirective.prototype, \"layers\", {\n            get: function () {\n                return this.layersValue;\n            },\n            // Set/get the layers\n            set: function (v) {\n                this.layersValue = v;\n                // Now that we have a differ, do an immediate layer update\n                this.updateLayers();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LeafletLayersDirective.prototype.ngDoCheck = function () {\n            this.updateLayers();\n        };\n        LeafletLayersDirective.prototype.ngOnInit = function () {\n            // Init the map\n            this.leafletDirective.init();\n            // Update layers once the map is ready\n            this.updateLayers();\n        };\n        LeafletLayersDirective.prototype.ngOnDestroy = function () {\n            this.layers = [];\n        };\n        /**\n         * Update the state of the layers.\n         * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n         * This is important because it allows us to react to changes to the contents of the array as well\n         * as changes to the actual array instance.\n         */\n        LeafletLayersDirective.prototype.updateLayers = function () {\n            var map = this.leafletDirective.getMap();\n            if (null != map && null != this.layersDiffer) {\n                var changes_1 = this.layersDiffer.diff(this.layersValue);\n                if (null != changes_1) {\n                    // Run outside angular to ensure layer events don't trigger change detection\n                    this.zone.runOutsideAngular(function () {\n                        changes_1.forEachRemovedItem(function (c) {\n                            map.removeLayer(c.item);\n                        });\n                        changes_1.forEachAddedItem(function (c) {\n                            map.addLayer(c.item);\n                        });\n                    });\n                }\n            }\n        };\n        __decorate([\n            core.Input('leafletLayers'),\n            __metadata(\"design:type\", Array),\n            __metadata(\"design:paramtypes\", [Array])\n        ], LeafletLayersDirective.prototype, \"layers\", null);\n        LeafletLayersDirective = __decorate([\n            core.Directive({\n                selector: '[leafletLayers]'\n            }),\n            __metadata(\"design:paramtypes\", [LeafletDirective, core.IterableDiffers, core.NgZone])\n        ], LeafletLayersDirective);\n        return LeafletLayersDirective;\n    }());\n\n    var LeafletControlLayersChanges = /** @class */ (function () {\n        function LeafletControlLayersChanges() {\n            this.layersRemoved = 0;\n            this.layersChanged = 0;\n            this.layersAdded = 0;\n        }\n        LeafletControlLayersChanges.prototype.changed = function () {\n            return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n        };\n        return LeafletControlLayersChanges;\n    }());\n\n    var LeafletControlLayersWrapper = /** @class */ (function () {\n        function LeafletControlLayersWrapper(zone, layersControlReady) {\n            this.zone = zone;\n            this.layersControlReady = layersControlReady;\n        }\n        LeafletControlLayersWrapper.prototype.getLayersControl = function () {\n            return this.layersControl;\n        };\n        LeafletControlLayersWrapper.prototype.init = function (controlConfig, controlOptions) {\n            var _this = this;\n            var baseLayers = controlConfig.baseLayers || {};\n            var overlays = controlConfig.overlays || {};\n            // Create the control outside of angular to ensure events don't trigger change detection\n            this.zone.runOutsideAngular(function () {\n                _this.layersControl = leaflet.control.layers(baseLayers, overlays, controlOptions);\n            });\n            this.layersControlReady.emit(this.layersControl);\n            return this.layersControl;\n        };\n        LeafletControlLayersWrapper.prototype.applyBaseLayerChanges = function (changes) {\n            var results = new LeafletControlLayersChanges();\n            if (null != this.layersControl) {\n                results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n            }\n            return results;\n        };\n        LeafletControlLayersWrapper.prototype.applyOverlayChanges = function (changes) {\n            var results = new LeafletControlLayersChanges();\n            if (null != this.layersControl) {\n                results = this.applyChanges(changes, this.layersControl.addOverlay);\n            }\n            return results;\n        };\n        LeafletControlLayersWrapper.prototype.applyChanges = function (changes, addFn) {\n            var _this = this;\n            var results = new LeafletControlLayersChanges();\n            if (null != changes) {\n                // All layer management is outside angular to avoid layer events from triggering change detection\n                this.zone.runOutsideAngular(function () {\n                    changes.forEachChangedItem(function (c) {\n                        _this.layersControl.removeLayer(c.previousValue);\n                        addFn.call(_this.layersControl, c.currentValue, c.key);\n                        results.layersChanged++;\n                    });\n                    changes.forEachRemovedItem(function (c) {\n                        _this.layersControl.removeLayer(c.previousValue);\n                        results.layersRemoved++;\n                    });\n                    changes.forEachAddedItem(function (c) {\n                        addFn.call(_this.layersControl, c.currentValue, c.key);\n                        results.layersAdded++;\n                    });\n                });\n            }\n            return results;\n        };\n        return LeafletControlLayersWrapper;\n    }());\n\n    var LeafletControlLayersConfig = /** @class */ (function () {\n        function LeafletControlLayersConfig() {\n            this.baseLayers = {};\n            this.overlays = {};\n        }\n        return LeafletControlLayersConfig;\n    }());\n\n    /**\n     * Layers Control\n     *\n     * This directive is used to configure the layers control. The input accepts an object with two\n     * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n     * used to determine what changed so that layers are appropriately added or removed.\n     *\n     * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n     * using the layers directive. Otherwise, the last one it sees will be used.\n     */\n    var LeafletLayersControlDirective = /** @class */ (function () {\n        function LeafletLayersControlDirective(leafletDirective, differs, zone) {\n            this.differs = differs;\n            this.zone = zone;\n            this.layersControlReady = new core.EventEmitter();\n            this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n            this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n            // Generate differs\n            this.baseLayersDiffer = this.differs.find({}).create();\n            this.overlaysDiffer = this.differs.find({}).create();\n        }\n        Object.defineProperty(LeafletLayersControlDirective.prototype, \"layersControlConfig\", {\n            get: function () {\n                return this.layersControlConfigValue;\n            },\n            set: function (v) {\n                // Validation/init stuff\n                if (null == v) {\n                    v = new LeafletControlLayersConfig();\n                }\n                if (null == v.baseLayers) {\n                    v.baseLayers = {};\n                }\n                if (null == v.overlays) {\n                    v.overlays = {};\n                }\n                // Store the value\n                this.layersControlConfigValue = v;\n                // Update the map\n                this.updateLayers();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LeafletLayersControlDirective.prototype.ngOnInit = function () {\n            var _this = this;\n            // Init the map\n            this.leafletDirective.init();\n            // Set up control outside of angular to avoid change detection when using the control\n            this.zone.runOutsideAngular(function () {\n                // Set up all the initial settings\n                _this.controlLayers\n                    .init({}, _this.layersControlOptions)\n                    .addTo(_this.leafletDirective.getMap());\n            });\n            this.updateLayers();\n        };\n        LeafletLayersControlDirective.prototype.ngOnDestroy = function () {\n            this.layersControlConfig = { baseLayers: {}, overlays: {} };\n            this.controlLayers.getLayersControl().remove();\n        };\n        LeafletLayersControlDirective.prototype.ngDoCheck = function () {\n            this.updateLayers();\n        };\n        LeafletLayersControlDirective.prototype.updateLayers = function () {\n            var map = this.leafletDirective.getMap();\n            var layersControl = this.controlLayers.getLayersControl();\n            if (null != map && null != layersControl) {\n                // Run the baselayers differ\n                if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n                    var changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n                    this.controlLayers.applyBaseLayerChanges(changes);\n                }\n                // Run the overlays differ\n                if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n                    var changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n                    this.controlLayers.applyOverlayChanges(changes);\n                }\n            }\n        };\n        __decorate([\n            core.Input('leafletLayersControl'),\n            __metadata(\"design:type\", LeafletControlLayersConfig),\n            __metadata(\"design:paramtypes\", [LeafletControlLayersConfig])\n        ], LeafletLayersControlDirective.prototype, \"layersControlConfig\", null);\n        __decorate([\n            core.Input('leafletLayersControlOptions'),\n            __metadata(\"design:type\", Object)\n        ], LeafletLayersControlDirective.prototype, \"layersControlOptions\", void 0);\n        __decorate([\n            core.Output('leafletLayersControlReady'),\n            __metadata(\"design:type\", Object)\n        ], LeafletLayersControlDirective.prototype, \"layersControlReady\", void 0);\n        LeafletLayersControlDirective = __decorate([\n            core.Directive({\n                selector: '[leafletLayersControl]'\n            }),\n            __metadata(\"design:paramtypes\", [LeafletDirective, core.KeyValueDiffers, core.NgZone])\n        ], LeafletLayersControlDirective);\n        return LeafletLayersControlDirective;\n    }());\n\n    /**\n     * Baselayers directive\n     *\n     * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n     * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n     * used to determine what changed so that layers are appropriately added or removed. This directive\n     * will also add the layers control so users can switch between available base layers.\n     *\n     * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n     * using the layers directive. Otherwise, the plugin will use the last one it sees.\n     */\n    var LeafletBaseLayersDirective = /** @class */ (function () {\n        function LeafletBaseLayersDirective(leafletDirective, differs, zone) {\n            this.differs = differs;\n            this.zone = zone;\n            // Output for once the layers control is ready\n            this.layersControlReady = new core.EventEmitter();\n            this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n            this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n            this.baseLayersDiffer = this.differs.find({}).create();\n        }\n        Object.defineProperty(LeafletBaseLayersDirective.prototype, \"baseLayers\", {\n            get: function () {\n                return this.baseLayersValue;\n            },\n            // Set/get baseLayers\n            set: function (v) {\n                this.baseLayersValue = v;\n                this.updateBaseLayers();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LeafletBaseLayersDirective.prototype.ngOnDestroy = function () {\n            this.baseLayers = {};\n            this.controlLayers.getLayersControl().remove();\n        };\n        LeafletBaseLayersDirective.prototype.ngOnInit = function () {\n            var _this = this;\n            // Init the map\n            this.leafletDirective.init();\n            // Create the control outside angular to prevent events from triggering chnage detection\n            this.zone.runOutsideAngular(function () {\n                // Initially configure the controlLayers\n                _this.controlLayers\n                    .init({}, _this.layersControlOptions)\n                    .addTo(_this.leafletDirective.getMap());\n            });\n            this.updateBaseLayers();\n        };\n        LeafletBaseLayersDirective.prototype.ngDoCheck = function () {\n            this.updateBaseLayers();\n        };\n        LeafletBaseLayersDirective.prototype.updateBaseLayers = function () {\n            var map = this.leafletDirective.getMap();\n            var layersControl = this.controlLayers.getLayersControl();\n            if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n                var changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n                var results = this.controlLayers.applyBaseLayerChanges(changes);\n                if (results.changed()) {\n                    this.syncBaseLayer();\n                }\n            }\n        };\n        /**\n         * Check the current base layer and change it to the new one if necessary\n         */\n        LeafletBaseLayersDirective.prototype.syncBaseLayer = function () {\n            var _this = this;\n            var map = this.leafletDirective.getMap();\n            var layers = LeafletUtil.mapToArray(this.baseLayers);\n            var foundLayer;\n            // Search all the layers in the map to see if we can find them in the baselayer array\n            map.eachLayer(function (l) {\n                foundLayer = layers.find(function (bl) { return (l === bl); });\n            });\n            // Did we find the layer?\n            if (null != foundLayer) {\n                // Yes - set the baselayer to the one we found\n                this.baseLayer = foundLayer;\n            }\n            else {\n                // No - set the baselayer to the first in the array and add it to the map\n                if (layers.length > 0) {\n                    this.baseLayer = layers[0];\n                    // Add layers outside of angular to prevent events from triggering change detection\n                    this.zone.runOutsideAngular(function () {\n                        _this.baseLayer.addTo(map);\n                    });\n                }\n            }\n        };\n        __decorate([\n            core.Input('leafletBaseLayers'),\n            __metadata(\"design:type\", Object),\n            __metadata(\"design:paramtypes\", [Object])\n        ], LeafletBaseLayersDirective.prototype, \"baseLayers\", null);\n        __decorate([\n            core.Input('leafletLayersControlOptions'),\n            __metadata(\"design:type\", Object)\n        ], LeafletBaseLayersDirective.prototype, \"layersControlOptions\", void 0);\n        __decorate([\n            core.Output('leafletLayersControlReady'),\n            __metadata(\"design:type\", Object)\n        ], LeafletBaseLayersDirective.prototype, \"layersControlReady\", void 0);\n        LeafletBaseLayersDirective = __decorate([\n            core.Directive({\n                selector: '[leafletBaseLayers]'\n            }),\n            __metadata(\"design:paramtypes\", [LeafletDirective, core.KeyValueDiffers, core.NgZone])\n        ], LeafletBaseLayersDirective);\n        return LeafletBaseLayersDirective;\n    }());\n\n    var LeafletModule = /** @class */ (function () {\n        function LeafletModule() {\n        }\n        LeafletModule = __decorate([\n            core.NgModule({\n                exports: [\n                    LeafletDirective,\n                    LeafletLayerDirective,\n                    LeafletLayersDirective,\n                    LeafletLayersControlDirective,\n                    LeafletBaseLayersDirective\n                ],\n                declarations: [\n                    LeafletDirective,\n                    LeafletLayerDirective,\n                    LeafletLayersDirective,\n                    LeafletLayersControlDirective,\n                    LeafletBaseLayersDirective\n                ]\n            })\n        ], LeafletModule);\n        return LeafletModule;\n    }());\n\n    var LeafletTileLayerDefinition = /** @class */ (function () {\n        function LeafletTileLayerDefinition(type, url, options) {\n            this.type = type;\n            this.url = url;\n            this.options = options;\n        }\n        /**\n         * Creates a TileLayer from the provided definition. This is a convenience function\n         * to help with generating layers from objects.\n         *\n         * @param layerDef The layer to create\n         * @returns {TileLayer} The TileLayer that has been created\n         */\n        LeafletTileLayerDefinition.createTileLayer = function (layerDef) {\n            var layer;\n            switch (layerDef.type) {\n                case 'xyz':\n                    layer = leaflet.tileLayer(layerDef.url, layerDef.options);\n                    break;\n                case 'wms':\n                default:\n                    layer = leaflet.tileLayer.wms(layerDef.url, layerDef.options);\n                    break;\n            }\n            return layer;\n        };\n        /**\n         * Creates a TileLayer for each key in the incoming map. This is a convenience function\n         * for generating an associative array of layers from an associative array of objects\n         *\n         * @param layerDefs A map of key to tile layer definition\n         * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n         */\n        LeafletTileLayerDefinition.createTileLayers = function (layerDefs) {\n            var layers = {};\n            for (var k in layerDefs) {\n                if (layerDefs.hasOwnProperty(k)) {\n                    layers[k] = (LeafletTileLayerDefinition.createTileLayer(layerDefs[k]));\n                }\n            }\n            return layers;\n        };\n        /**\n         * Create a Tile Layer from the current state of this object\n         *\n         * @returns {TileLayer} A new TileLayer\n         */\n        LeafletTileLayerDefinition.prototype.createTileLayer = function () {\n            return LeafletTileLayerDefinition.createTileLayer(this);\n        };\n        return LeafletTileLayerDefinition;\n    }());\n\n    exports.LeafletBaseLayersDirective = LeafletBaseLayersDirective;\n    exports.LeafletControlLayersChanges = LeafletControlLayersChanges;\n    exports.LeafletControlLayersConfig = LeafletControlLayersConfig;\n    exports.LeafletControlLayersWrapper = LeafletControlLayersWrapper;\n    exports.LeafletDirective = LeafletDirective;\n    exports.LeafletDirectiveWrapper = LeafletDirectiveWrapper;\n    exports.LeafletLayerDirective = LeafletLayerDirective;\n    exports.LeafletLayersControlDirective = LeafletLayersControlDirective;\n    exports.LeafletLayersDirective = LeafletLayersDirective;\n    exports.LeafletModule = LeafletModule;\n    exports.LeafletTileLayerDefinition = LeafletTileLayerDefinition;\n    exports.LeafletUtil = LeafletUtil;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}