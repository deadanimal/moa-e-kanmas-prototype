import { __decorate, __metadata, __param } from "tslib";
import { Injectable, Inject } from '@angular/core';
import { JwtHelperService } from './jwthelper.service';
import { JWT_OPTIONS } from './jwtoptions.token';
import { mergeMap } from 'rxjs/operators';
import { parse } from 'url';
import { from } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
let JwtInterceptor = class JwtInterceptor {
    constructor(config, jwtHelper) {
        this.jwtHelper = jwtHelper;
        this.tokenGetter = config.tokenGetter;
        this.headerName = config.headerName || 'Authorization';
        this.authScheme =
            config.authScheme || config.authScheme === ''
                ? config.authScheme
                : 'Bearer ';
        this.whitelistedDomains = config.whitelistedDomains || [];
        this.blacklistedRoutes = config.blacklistedRoutes || [];
        this.throwNoTokenError = config.throwNoTokenError || false;
        this.skipWhenExpired = config.skipWhenExpired;
    }
    isWhitelistedDomain(request) {
        const requestUrl = parse(request.url, false, true);
        return (requestUrl.host === null ||
            this.whitelistedDomains.findIndex(domain => typeof domain === 'string'
                ? domain === requestUrl.host
                : domain instanceof RegExp
                    ? domain.test(requestUrl.host)
                    : false) > -1);
    }
    isBlacklistedRoute(request) {
        const url = request.url;
        return (this.blacklistedRoutes.findIndex(route => typeof route === 'string'
            ? route === url
            : route instanceof RegExp
                ? route.test(url)
                : false) > -1);
    }
    handleInterception(token, request, next) {
        let tokenIsExpired = false;
        if (!token && this.throwNoTokenError) {
            throw new Error('Could not get token from tokenGetter function.');
        }
        if (this.skipWhenExpired) {
            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;
        }
        if (token && tokenIsExpired && this.skipWhenExpired) {
            request = request.clone();
        }
        else if (token) {
            request = request.clone({
                setHeaders: {
                    [this.headerName]: `${this.authScheme}${token}`
                }
            });
        }
        return next.handle(request);
    }
    intercept(request, next) {
        if (!this.isWhitelistedDomain(request) ||
            this.isBlacklistedRoute(request)) {
            return next.handle(request);
        }
        const token = this.tokenGetter();
        if (token instanceof Promise) {
            return from(token).pipe(mergeMap((asyncToken) => {
                return this.handleInterception(asyncToken, request, next);
            }));
        }
        else {
            return this.handleInterception(token, request, next);
        }
    }
};
JwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) { return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService)); };
JwtInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: JwtInterceptor, factory: JwtInterceptor.ɵfac });
JwtInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] },
    { type: JwtHelperService }
];
JwtInterceptor = __decorate([ __param(0, Inject(JWT_OPTIONS)),
    __metadata("design:paramtypes", [Object, JwtHelperService])
], JwtInterceptor);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(JwtInterceptor, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [JWT_OPTIONS]
            }] }, { type: JwtHelperService }]; }, null); })();
export { JwtInterceptor };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wbnNiL0Rlc2t0b3AvTU9BIC0gRS1LQU5NQVMvbm9kZV9tb2R1bGVzL0BhdXRoMC9hbmd1bGFyLWp3dC9lc20yMDE1L2xpYi9qd3QuaW50ZXJjZXB0b3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBHQWtFRTs7Ozs7NkJBSzJCLEFBRTFCOzs7Ozs7Ozs4REFFZ0IiLCJmaWxlIjoiand0LmludGVyY2VwdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19tZXRhZGF0YSwgX19wYXJhbSB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBKd3RIZWxwZXJTZXJ2aWNlIH0gZnJvbSAnLi9qd3RoZWxwZXIuc2VydmljZSc7XG5pbXBvcnQgeyBKV1RfT1BUSU9OUyB9IGZyb20gJy4vand0b3B0aW9ucy50b2tlbic7XG5pbXBvcnQgeyBtZXJnZU1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAndXJsJztcbmltcG9ydCB7IGZyb20gfSBmcm9tICdyeGpzJztcbmxldCBKd3RJbnRlcmNlcHRvciA9IGNsYXNzIEp3dEludGVyY2VwdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGp3dEhlbHBlcikge1xuICAgICAgICB0aGlzLmp3dEhlbHBlciA9IGp3dEhlbHBlcjtcbiAgICAgICAgdGhpcy50b2tlbkdldHRlciA9IGNvbmZpZy50b2tlbkdldHRlcjtcbiAgICAgICAgdGhpcy5oZWFkZXJOYW1lID0gY29uZmlnLmhlYWRlck5hbWUgfHwgJ0F1dGhvcml6YXRpb24nO1xuICAgICAgICB0aGlzLmF1dGhTY2hlbWUgPVxuICAgICAgICAgICAgY29uZmlnLmF1dGhTY2hlbWUgfHwgY29uZmlnLmF1dGhTY2hlbWUgPT09ICcnXG4gICAgICAgICAgICAgICAgPyBjb25maWcuYXV0aFNjaGVtZVxuICAgICAgICAgICAgICAgIDogJ0JlYXJlciAnO1xuICAgICAgICB0aGlzLndoaXRlbGlzdGVkRG9tYWlucyA9IGNvbmZpZy53aGl0ZWxpc3RlZERvbWFpbnMgfHwgW107XG4gICAgICAgIHRoaXMuYmxhY2tsaXN0ZWRSb3V0ZXMgPSBjb25maWcuYmxhY2tsaXN0ZWRSb3V0ZXMgfHwgW107XG4gICAgICAgIHRoaXMudGhyb3dOb1Rva2VuRXJyb3IgPSBjb25maWcudGhyb3dOb1Rva2VuRXJyb3IgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuc2tpcFdoZW5FeHBpcmVkID0gY29uZmlnLnNraXBXaGVuRXhwaXJlZDtcbiAgICB9XG4gICAgaXNXaGl0ZWxpc3RlZERvbWFpbihyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RVcmwgPSBwYXJzZShyZXF1ZXN0LnVybCwgZmFsc2UsIHRydWUpO1xuICAgICAgICByZXR1cm4gKHJlcXVlc3RVcmwuaG9zdCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy53aGl0ZWxpc3RlZERvbWFpbnMuZmluZEluZGV4KGRvbWFpbiA9PiB0eXBlb2YgZG9tYWluID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gZG9tYWluID09PSByZXF1ZXN0VXJsLmhvc3RcbiAgICAgICAgICAgICAgICA6IGRvbWFpbiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICA/IGRvbWFpbi50ZXN0KHJlcXVlc3RVcmwuaG9zdClcbiAgICAgICAgICAgICAgICAgICAgOiBmYWxzZSkgPiAtMSk7XG4gICAgfVxuICAgIGlzQmxhY2tsaXN0ZWRSb3V0ZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHJlcXVlc3QudXJsO1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxhY2tsaXN0ZWRSb3V0ZXMuZmluZEluZGV4KHJvdXRlID0+IHR5cGVvZiByb3V0ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gcm91dGUgPT09IHVybFxuICAgICAgICAgICAgOiByb3V0ZSBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgICAgID8gcm91dGUudGVzdCh1cmwpXG4gICAgICAgICAgICAgICAgOiBmYWxzZSkgPiAtMSk7XG4gICAgfVxuICAgIGhhbmRsZUludGVyY2VwdGlvbih0b2tlbiwgcmVxdWVzdCwgbmV4dCkge1xuICAgICAgICBsZXQgdG9rZW5Jc0V4cGlyZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0b2tlbiAmJiB0aGlzLnRocm93Tm9Ub2tlbkVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgdG9rZW4gZnJvbSB0b2tlbkdldHRlciBmdW5jdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5za2lwV2hlbkV4cGlyZWQpIHtcbiAgICAgICAgICAgIHRva2VuSXNFeHBpcmVkID0gdG9rZW4gPyB0aGlzLmp3dEhlbHBlci5pc1Rva2VuRXhwaXJlZCh0b2tlbikgOiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbklzRXhwaXJlZCAmJiB0aGlzLnNraXBXaGVuRXhwaXJlZCkge1xuICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QuY2xvbmUoe1xuICAgICAgICAgICAgICAgIHNldEhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuaGVhZGVyTmFtZV06IGAke3RoaXMuYXV0aFNjaGVtZX0ke3Rva2VufWBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxdWVzdCk7XG4gICAgfVxuICAgIGludGVyY2VwdChyZXF1ZXN0LCBuZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1doaXRlbGlzdGVkRG9tYWluKHJlcXVlc3QpIHx8XG4gICAgICAgICAgICB0aGlzLmlzQmxhY2tsaXN0ZWRSb3V0ZShyZXF1ZXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy50b2tlbkdldHRlcigpO1xuICAgICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbSh0b2tlbikucGlwZShtZXJnZU1hcCgoYXN5bmNUb2tlbikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUludGVyY2VwdGlvbihhc3luY1Rva2VuLCByZXF1ZXN0LCBuZXh0KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUludGVyY2VwdGlvbih0b2tlbiwgcmVxdWVzdCwgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuSnd0SW50ZXJjZXB0b3IuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW0pXVF9PUFRJT05TLF0gfV0gfSxcbiAgICB7IHR5cGU6IEp3dEhlbHBlclNlcnZpY2UgfVxuXTtcbkp3dEludGVyY2VwdG9yID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0oMCwgSW5qZWN0KEpXVF9PUFRJT05TKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIEp3dEhlbHBlclNlcnZpY2VdKVxuXSwgSnd0SW50ZXJjZXB0b3IpO1xuZXhwb3J0IHsgSnd0SW50ZXJjZXB0b3IgfTtcbiJdfQ==