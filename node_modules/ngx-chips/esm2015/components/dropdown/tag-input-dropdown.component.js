import * as tslib_1 from "tslib";
import { Component, ContentChildren, HostListener, Injector, Input, QueryList, TemplateRef, ViewChild } from '@angular/core';
import { filter, first, debounceTime } from 'rxjs/operators';
import { Ng2Dropdown } from 'ng2-material-dropdown';
import { defaults } from '../../defaults';
import { TagInputComponent } from '../tag-input/tag-input';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'ng2-material-dropdown';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '../../core/pipes/highlight.pipe';

function TagInputDropdown_ng2_menu_item_2_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 6);
    ɵngcc0.ɵɵpipe(1, "highlight");
} if (rf & 2) {
    const item_r345 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r348 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ɵngcc0.ɵɵpipeBind2(1, 1, item_r345[ctx_r348.displayBy], ctx_r348.tagInput.inputForm.value.value), ɵngcc0.ɵɵsanitizeHtml);
} }
function TagInputDropdown_ng2_menu_item_2_2_ng_template_0_Template(rf, ctx) { }
const _c0 = function (a0, a1, a2) { return { item: a0, index: a1, last: a2 }; };
function TagInputDropdown_ng2_menu_item_2_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TagInputDropdown_ng2_menu_item_2_2_ng_template_0_Template, 0, 0, "ng-template", 7);
} if (rf & 2) {
    const ctx_r352 = ɵngcc0.ɵɵnextContext();
    const item_r345 = ctx_r352.$implicit;
    const index_r346 = ctx_r352.index;
    const last_r347 = ctx_r352.last;
    const ctx_r349 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r349.templates.first)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction3(2, _c0, item_r345, index_r346, last_r347));
} }
function TagInputDropdown_ng2_menu_item_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ng2-menu-item", 3);
    ɵngcc0.ɵɵtemplate(1, TagInputDropdown_ng2_menu_item_2_span_1_Template, 2, 4, "span", 4);
    ɵngcc0.ɵɵtemplate(2, TagInputDropdown_ng2_menu_item_2_2_Template, 1, 6, undefined, 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r345 = ctx.$implicit;
    const ctx_r344 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", item_r345)("ngSwitch", !!ctx_r344.templates.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", false);
} }
let TagInputDropdown = class TagInputDropdown {
    constructor(injector) {
        this.injector = injector;
        /**
         * @name offset
         */
        this.offset = defaults.dropdown.offset;
        /**
         * @name focusFirstElement
         */
        this.focusFirstElement = defaults.dropdown.focusFirstElement;
        /**
         * - show autocomplete dropdown if the value of input is empty
         * @name showDropdownIfEmpty
         */
        this.showDropdownIfEmpty = defaults.dropdown.showDropdownIfEmpty;
        /**
         * - desc minimum text length in order to display the autocomplete dropdown
         * @name minimumTextLength
         */
        this.minimumTextLength = defaults.dropdown.minimumTextLength;
        /**
         * - number of items to display in the autocomplete dropdown
         * @name limitItemsTo
         */
        this.limitItemsTo = defaults.dropdown.limitItemsTo;
        /**
         * @name displayBy
         */
        this.displayBy = defaults.dropdown.displayBy;
        /**
         * @name identifyBy
         */
        this.identifyBy = defaults.dropdown.identifyBy;
        /**
         * @description a function a developer can use to implement custom matching for the autocomplete
         * @name matchingFn
         */
        this.matchingFn = defaults.dropdown.matchingFn;
        /**
         * @name appendToBody
         */
        this.appendToBody = defaults.dropdown.appendToBody;
        /**
         * @name keepOpen
         * @description option to leave dropdown open when adding a new item
         */
        this.keepOpen = defaults.dropdown.keepOpen;
        /**
         * @name dynamicUpdate
         */
        this.dynamicUpdate = defaults.dropdown.dynamicUpdate;
        /**
         * @name zIndex
         */
        this.zIndex = defaults.dropdown.zIndex;
        /**
         * list of items that match the current value of the input (for autocomplete)
         * @name items
         */
        this.items = [];
        /**
         * @name tagInput
         */
        this.tagInput = this.injector.get(TagInputComponent);
        /**
         * @name _autocompleteItems
         */
        this._autocompleteItems = [];
        /**
         *
         * @name show
         */
        this.show = () => {
            const maxItemsReached = this.tagInput.items.length === this.tagInput.maxItems;
            const value = this.getFormValue();
            const hasMinimumText = value.trim().length >= this.minimumTextLength;
            const position = this.calculatePosition();
            const items = this.getMatchingItems(value);
            const hasItems = items.length > 0;
            const isHidden = this.isVisible === false;
            const showDropdownIfEmpty = this.showDropdownIfEmpty && hasItems && !value;
            const isDisabled = this.tagInput.disable;
            const shouldShow = isHidden && ((hasItems && hasMinimumText) || showDropdownIfEmpty);
            const shouldHide = this.isVisible && !hasItems;
            if (this.autocompleteObservable && hasMinimumText) {
                return this.getItemsFromObservable(value);
            }
            if ((!this.showDropdownIfEmpty && !value) ||
                maxItemsReached ||
                isDisabled) {
                return this.dropdown.hide();
            }
            this.setItems(items);
            if (shouldShow) {
                this.dropdown.show(position);
            }
            else if (shouldHide) {
                this.hide();
            }
        };
        /**
         * @name requestAdding
         * @param item {Ng2MenuItem}
         */
        this.requestAdding = (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tag = this.createTagModel(item);
            yield this.tagInput.onAddingRequested(true, tag).catch(() => { });
        });
        /**
         * @name resetItems
         */
        this.resetItems = () => {
            this.items = [];
        };
        /**
         * @name getItemsFromObservable
         * @param text
         */
        this.getItemsFromObservable = (text) => {
            this.setLoadingState(true);
            const subscribeFn = (data) => {
                // hide loading animation
                this.setLoadingState(false)
                    // add items
                    .populateItems(data);
                this.setItems(this.getMatchingItems(text));
                if (this.items.length) {
                    this.dropdown.show(this.calculatePosition());
                }
                else {
                    this.dropdown.hide();
                }
            };
            this.autocompleteObservable(text)
                .pipe(first())
                .subscribe(subscribeFn, () => this.setLoadingState(false));
        };
    }
    /**
     * @name autocompleteItems
     * @param items
     */
    set autocompleteItems(items) {
        this._autocompleteItems = items;
    }
    /**
     * @name autocompleteItems
     * @desc array of items that will populate the autocomplete
     */
    get autocompleteItems() {
        const items = this._autocompleteItems;
        if (!items) {
            return [];
        }
        return items.map((item) => {
            return typeof item === 'string'
                ? {
                    [this.displayBy]: item,
                    [this.identifyBy]: item
                }
                : item;
        });
    }
    /**
     * @name ngAfterviewInit
     */
    ngAfterViewInit() {
        this.onItemClicked().subscribe((item) => {
            this.requestAdding(item);
        });
        // reset itemsMatching array when the dropdown is hidden
        this.onHide().subscribe(this.resetItems);
        const DEBOUNCE_TIME = 200;
        const KEEP_OPEN = this.keepOpen;
        this.tagInput.onTextChange
            .asObservable()
            .pipe(debounceTime(DEBOUNCE_TIME), filter((value) => {
            if (KEEP_OPEN === false) {
                return value.length > 0;
            }
            return true;
        }))
            .subscribe(this.show);
    }
    /**
     * @name updatePosition
     */
    updatePosition() {
        const position = this.tagInput.inputForm.getElementPosition();
        this.dropdown.menu.updatePosition(position, this.dynamicUpdate);
    }
    /**
     * @name isVisible
     */
    get isVisible() {
        return this.dropdown.menu.dropdownState.menuState.isVisible;
    }
    /**
     * @name onHide
     */
    onHide() {
        return this.dropdown.onHide;
    }
    /**
     * @name onItemClicked
     */
    onItemClicked() {
        return this.dropdown.onItemClicked;
    }
    /**
     * @name selectedItem
     */
    get selectedItem() {
        return this.dropdown.menu.dropdownState.dropdownState.selectedItem;
    }
    /**
     * @name state
     */
    get state() {
        return this.dropdown.menu.dropdownState;
    }
    /**
     * @name hide
     */
    hide() {
        this.resetItems();
        this.dropdown.hide();
    }
    /**
     * @name scrollListener
     */
    scrollListener() {
        if (!this.isVisible || !this.dynamicUpdate) {
            return;
        }
        this.updatePosition();
    }
    /**
     * @name onWindowBlur
     */
    onWindowBlur() {
        this.dropdown.hide();
    }
    /**
     * @name getFormValue
     */
    getFormValue() {
        const formValue = this.tagInput.formValue;
        return formValue ? formValue.toString().trim() : '';
    }
    /**
     * @name calculatePosition
     */
    calculatePosition() {
        return this.tagInput.inputForm.getElementPosition();
    }
    /**
     * @name createTagModel
     * @param item
     */
    createTagModel(item) {
        const display = typeof item.value === 'string' ? item.value : item.value[this.displayBy];
        const value = typeof item.value === 'string' ? item.value : item.value[this.identifyBy];
        return Object.assign({}, item.value, { [this.tagInput.displayBy]: display, [this.tagInput.identifyBy]: value });
    }
    /**
     *
     * @param value {string}
     */
    getMatchingItems(value) {
        if (!value && !this.showDropdownIfEmpty) {
            return [];
        }
        const dupesAllowed = this.tagInput.allowDupes;
        return this.autocompleteItems.filter((item) => {
            const hasValue = dupesAllowed
                ? false
                : this.tagInput.tags.some(tag => {
                    const identifyBy = this.tagInput.identifyBy;
                    const model = typeof tag.model === 'string' ? tag.model : tag.model[identifyBy];
                    return model === item[this.identifyBy];
                });
            return this.matchingFn(value, item) && hasValue === false;
        });
    }
    /**
     * @name setItems
     */
    setItems(items) {
        this.items = items.slice(0, this.limitItemsTo || items.length);
    }
    /**
     * @name populateItems
     * @param data
     */
    populateItems(data) {
        this.autocompleteItems = data.map(item => {
            return typeof item === 'string'
                ? {
                    [this.displayBy]: item,
                    [this.identifyBy]: item
                }
                : item;
        });
        return this;
    }
    /**
     * @name setLoadingState
     * @param state
     */
    setLoadingState(state) {
        this.tagInput.isLoading = state;
        return this;
    }
};
TagInputDropdown.ɵfac = function TagInputDropdown_Factory(t) { return new (t || TagInputDropdown)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
TagInputDropdown.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TagInputDropdown, selectors: [["tag-input-dropdown"]], contentQueries: function TagInputDropdown_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TemplateRef, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templates = _t);
    } }, viewQuery: function TagInputDropdown_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(Ng2Dropdown, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdown = _t.first);
    } }, hostBindings: function TagInputDropdown_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function TagInputDropdown_scroll_HostBindingHandler($event) { return ctx.scrollListener(); }, false, ɵngcc0.ɵɵresolveWindow)("blur", function TagInputDropdown_blur_HostBindingHandler($event) { return ctx.onWindowBlur(); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, inputs: { offset: "offset", focusFirstElement: "focusFirstElement", showDropdownIfEmpty: "showDropdownIfEmpty", minimumTextLength: "minimumTextLength", limitItemsTo: "limitItemsTo", displayBy: "displayBy", identifyBy: "identifyBy", matchingFn: "matchingFn", appendToBody: "appendToBody", keepOpen: "keepOpen", dynamicUpdate: "dynamicUpdate", zIndex: "zIndex", autocompleteItems: "autocompleteItems", autocompleteObservable: "autocompleteObservable" }, decls: 3, vars: 6, consts: [[3, "dynamicUpdate"], [3, "focusFirstElement", "zIndex", "appendToBody", "offset"], [3, "value", "ngSwitch", 4, "ngFor", "ngForOf"], [3, "value", "ngSwitch"], [3, "innerHTML", 4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "innerHTML"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function TagInputDropdown_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ng2-dropdown", 0);
        ɵngcc0.ɵɵelementStart(1, "ng2-dropdown-menu", 1);
        ɵngcc0.ɵɵtemplate(2, TagInputDropdown_ng2_menu_item_2_Template, 3, 3, "ng2-menu-item", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("dynamicUpdate", ctx.dynamicUpdate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("focusFirstElement", ctx.focusFirstElement)("zIndex", ctx.zIndex)("appendToBody", ctx.appendToBody)("offset", ctx.offset);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc1.Ng2Dropdown, ɵngcc1.Ng2DropdownMenu, ɵngcc2.NgForOf, ɵngcc1.Ng2MenuItem, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault, ɵngcc2.NgTemplateOutlet], pipes: [ɵngcc3.HighlightPipe], encapsulation: 2 });
tslib_1.__decorate([
    ViewChild(Ng2Dropdown, { static: false }),
    tslib_1.__metadata("design:type", Ng2Dropdown)
], TagInputDropdown.prototype, "dropdown", void 0);
tslib_1.__decorate([
    ContentChildren(TemplateRef),
    tslib_1.__metadata("design:type", QueryList)
], TagInputDropdown.prototype, "templates", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], TagInputDropdown.prototype, "offset", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], TagInputDropdown.prototype, "focusFirstElement", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], TagInputDropdown.prototype, "showDropdownIfEmpty", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Function)
], TagInputDropdown.prototype, "autocompleteObservable", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], TagInputDropdown.prototype, "minimumTextLength", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], TagInputDropdown.prototype, "limitItemsTo", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], TagInputDropdown.prototype, "displayBy", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], TagInputDropdown.prototype, "identifyBy", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Function)
], TagInputDropdown.prototype, "matchingFn", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], TagInputDropdown.prototype, "appendToBody", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], TagInputDropdown.prototype, "keepOpen", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], TagInputDropdown.prototype, "dynamicUpdate", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], TagInputDropdown.prototype, "zIndex", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Array),
    tslib_1.__metadata("design:paramtypes", [Array])
], TagInputDropdown.prototype, "autocompleteItems", null);
tslib_1.__decorate([
    HostListener('window:scroll'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TagInputDropdown.prototype, "scrollListener", null);
tslib_1.__decorate([
    HostListener('window:blur'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TagInputDropdown.prototype, "onWindowBlur", null);
TagInputDropdown = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [Injector])
], TagInputDropdown);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TagInputDropdown, [{
        type: Component,
        args: [{
                selector: 'tag-input-dropdown',
                template: "<ng2-dropdown [dynamicUpdate]=\"dynamicUpdate\">\n    <ng2-dropdown-menu [focusFirstElement]=\"focusFirstElement\"\n                       [zIndex]=\"zIndex\"\n                       [appendToBody]=\"appendToBody\"\n                       [offset]=\"offset\">\n        <ng2-menu-item *ngFor=\"let item of items; let index = index; let last = last\"\n                       [value]=\"item\"\n                       [ngSwitch]=\"!!templates.length\">\n\n            <span *ngSwitchCase=\"false\"\n                  [innerHTML]=\"item[displayBy] | highlight : tagInput.inputForm.value.value\">\n            </span>\n\n            <ng-template *ngSwitchDefault\n                      [ngTemplateOutlet]=\"templates.first\"\n                      [ngTemplateOutletContext]=\"{ item: item, index: index, last: last }\">\n            </ng-template>\n        </ng2-menu-item>\n    </ng2-dropdown-menu>\n</ng2-dropdown>\n"
            }]
    }], function () { return [{ type: ɵngcc0.Injector }]; }, { offset: [{
            type: Input
        }], focusFirstElement: [{
            type: Input
        }], showDropdownIfEmpty: [{
            type: Input
        }], minimumTextLength: [{
            type: Input
        }], limitItemsTo: [{
            type: Input
        }], displayBy: [{
            type: Input
        }], identifyBy: [{
            type: Input
        }], matchingFn: [{
            type: Input
        }], appendToBody: [{
            type: Input
        }], keepOpen: [{
            type: Input
        }], dynamicUpdate: [{
            type: Input
        }], zIndex: [{
            type: Input
        }], autocompleteItems: [{
            type: Input
        }], scrollListener: [{
            type: HostListener,
            args: ['window:scroll']
        }], onWindowBlur: [{
            type: HostListener,
            args: ['window:blur']
        }], dropdown: [{
            type: ViewChild,
            args: [Ng2Dropdown, { static: false }]
        }], templates: [{
            type: ContentChildren,
            args: [TemplateRef]
        }], autocompleteObservable: [{
            type: Input
        }] }); })();
export { TagInputDropdown };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wbnNiL0Rlc2t0b3AvTU9BIC0gRS1LQU5NQVMvbm9kZV9tb2R1bGVzL25neC1jaGlwcy9lc20yMDE1L2NvbXBvbmVudHMvZHJvcGRvd24vdGFnLWlucHV0LWRyb3Bkb3duLmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpUEEyVEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0E4RXFDLEFBS3BDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQ2tCIiwiZmlsZSI6InRhZy1pbnB1dC1kcm9wZG93bi5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEhvc3RMaXN0ZW5lciwgSW5qZWN0b3IsIElucHV0LCBRdWVyeUxpc3QsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciwgZmlyc3QsIGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE5nMkRyb3Bkb3duIH0gZnJvbSAnbmcyLW1hdGVyaWFsLWRyb3Bkb3duJztcbmltcG9ydCB7IGRlZmF1bHRzIH0gZnJvbSAnLi4vLi4vZGVmYXVsdHMnO1xuaW1wb3J0IHsgVGFnSW5wdXRDb21wb25lbnQgfSBmcm9tICcuLi90YWctaW5wdXQvdGFnLWlucHV0JztcbmxldCBUYWdJbnB1dERyb3Bkb3duID0gY2xhc3MgVGFnSW5wdXREcm9wZG93biB7XG4gICAgY29uc3RydWN0b3IoaW5qZWN0b3IpIHtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgb2Zmc2V0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IGRlZmF1bHRzLmRyb3Bkb3duLm9mZnNldDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGZvY3VzRmlyc3RFbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzRmlyc3RFbGVtZW50ID0gZGVmYXVsdHMuZHJvcGRvd24uZm9jdXNGaXJzdEVsZW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAtIHNob3cgYXV0b2NvbXBsZXRlIGRyb3Bkb3duIGlmIHRoZSB2YWx1ZSBvZiBpbnB1dCBpcyBlbXB0eVxuICAgICAgICAgKiBAbmFtZSBzaG93RHJvcGRvd25JZkVtcHR5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dEcm9wZG93bklmRW1wdHkgPSBkZWZhdWx0cy5kcm9wZG93bi5zaG93RHJvcGRvd25JZkVtcHR5O1xuICAgICAgICAvKipcbiAgICAgICAgICogLSBkZXNjIG1pbmltdW0gdGV4dCBsZW5ndGggaW4gb3JkZXIgdG8gZGlzcGxheSB0aGUgYXV0b2NvbXBsZXRlIGRyb3Bkb3duXG4gICAgICAgICAqIEBuYW1lIG1pbmltdW1UZXh0TGVuZ3RoXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbmltdW1UZXh0TGVuZ3RoID0gZGVmYXVsdHMuZHJvcGRvd24ubWluaW11bVRleHRMZW5ndGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAtIG51bWJlciBvZiBpdGVtcyB0byBkaXNwbGF5IGluIHRoZSBhdXRvY29tcGxldGUgZHJvcGRvd25cbiAgICAgICAgICogQG5hbWUgbGltaXRJdGVtc1RvXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbWl0SXRlbXNUbyA9IGRlZmF1bHRzLmRyb3Bkb3duLmxpbWl0SXRlbXNUbztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGRpc3BsYXlCeVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNwbGF5QnkgPSBkZWZhdWx0cy5kcm9wZG93bi5kaXNwbGF5Qnk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBpZGVudGlmeUJ5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkZW50aWZ5QnkgPSBkZWZhdWx0cy5kcm9wZG93bi5pZGVudGlmeUJ5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIGEgZnVuY3Rpb24gYSBkZXZlbG9wZXIgY2FuIHVzZSB0byBpbXBsZW1lbnQgY3VzdG9tIG1hdGNoaW5nIGZvciB0aGUgYXV0b2NvbXBsZXRlXG4gICAgICAgICAqIEBuYW1lIG1hdGNoaW5nRm5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF0Y2hpbmdGbiA9IGRlZmF1bHRzLmRyb3Bkb3duLm1hdGNoaW5nRm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBhcHBlbmRUb0JvZHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXBwZW5kVG9Cb2R5ID0gZGVmYXVsdHMuZHJvcGRvd24uYXBwZW5kVG9Cb2R5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUga2VlcE9wZW5cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIG9wdGlvbiB0byBsZWF2ZSBkcm9wZG93biBvcGVuIHdoZW4gYWRkaW5nIGEgbmV3IGl0ZW1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcE9wZW4gPSBkZWZhdWx0cy5kcm9wZG93bi5rZWVwT3BlbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGR5bmFtaWNVcGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHluYW1pY1VwZGF0ZSA9IGRlZmF1bHRzLmRyb3Bkb3duLmR5bmFtaWNVcGRhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSB6SW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuekluZGV4ID0gZGVmYXVsdHMuZHJvcGRvd24uekluZGV4O1xuICAgICAgICAvKipcbiAgICAgICAgICogbGlzdCBvZiBpdGVtcyB0aGF0IG1hdGNoIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCAoZm9yIGF1dG9jb21wbGV0ZSlcbiAgICAgICAgICogQG5hbWUgaXRlbXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIHRhZ0lucHV0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZ0lucHV0ID0gdGhpcy5pbmplY3Rvci5nZXQoVGFnSW5wdXRDb21wb25lbnQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgX2F1dG9jb21wbGV0ZUl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hdXRvY29tcGxldGVJdGVtcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgc2hvd1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF4SXRlbXNSZWFjaGVkID0gdGhpcy50YWdJbnB1dC5pdGVtcy5sZW5ndGggPT09IHRoaXMudGFnSW5wdXQubWF4SXRlbXM7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0Rm9ybVZhbHVlKCk7XG4gICAgICAgICAgICBjb25zdCBoYXNNaW5pbXVtVGV4dCA9IHZhbHVlLnRyaW0oKS5sZW5ndGggPj0gdGhpcy5taW5pbXVtVGV4dExlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmdldE1hdGNoaW5nSXRlbXModmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgaGFzSXRlbXMgPSBpdGVtcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgY29uc3QgaXNIaWRkZW4gPSB0aGlzLmlzVmlzaWJsZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzaG93RHJvcGRvd25JZkVtcHR5ID0gdGhpcy5zaG93RHJvcGRvd25JZkVtcHR5ICYmIGhhc0l0ZW1zICYmICF2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGlzRGlzYWJsZWQgPSB0aGlzLnRhZ0lucHV0LmRpc2FibGU7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTaG93ID0gaXNIaWRkZW4gJiYgKChoYXNJdGVtcyAmJiBoYXNNaW5pbXVtVGV4dCkgfHwgc2hvd0Ryb3Bkb3duSWZFbXB0eSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRIaWRlID0gdGhpcy5pc1Zpc2libGUgJiYgIWhhc0l0ZW1zO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b2NvbXBsZXRlT2JzZXJ2YWJsZSAmJiBoYXNNaW5pbXVtVGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW1zRnJvbU9ic2VydmFibGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghdGhpcy5zaG93RHJvcGRvd25JZkVtcHR5ICYmICF2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBtYXhJdGVtc1JlYWNoZWQgfHxcbiAgICAgICAgICAgICAgICBpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRJdGVtcyhpdGVtcyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2hvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uc2hvdyhwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaG91bGRIaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSByZXF1ZXN0QWRkaW5nXG4gICAgICAgICAqIEBwYXJhbSBpdGVtIHtOZzJNZW51SXRlbX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVxdWVzdEFkZGluZyA9IChpdGVtKSA9PiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRoaXMuY3JlYXRlVGFnTW9kZWwoaXRlbSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnRhZ0lucHV0Lm9uQWRkaW5nUmVxdWVzdGVkKHRydWUsIHRhZykuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSByZXNldEl0ZW1zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2V0SXRlbXMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBnZXRJdGVtc0Zyb21PYnNlcnZhYmxlXG4gICAgICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEl0ZW1zRnJvbU9ic2VydmFibGUgPSAodGV4dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRMb2FkaW5nU3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVGbiA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaGlkZSBsb2FkaW5nIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TG9hZGluZ1N0YXRlKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgLnBvcHVsYXRlSXRlbXMoZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtcyh0aGlzLmdldE1hdGNoaW5nSXRlbXModGV4dCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLnNob3codGhpcy5jYWxjdWxhdGVQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZU9ic2VydmFibGUodGV4dClcbiAgICAgICAgICAgICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoc3Vic2NyaWJlRm4sICgpID0+IHRoaXMuc2V0TG9hZGluZ1N0YXRlKGZhbHNlKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuYW1lIGF1dG9jb21wbGV0ZUl0ZW1zXG4gICAgICogQHBhcmFtIGl0ZW1zXG4gICAgICovXG4gICAgc2V0IGF1dG9jb21wbGV0ZUl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuX2F1dG9jb21wbGV0ZUl0ZW1zID0gaXRlbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuYW1lIGF1dG9jb21wbGV0ZUl0ZW1zXG4gICAgICogQGRlc2MgYXJyYXkgb2YgaXRlbXMgdGhhdCB3aWxsIHBvcHVsYXRlIHRoZSBhdXRvY29tcGxldGVcbiAgICAgKi9cbiAgICBnZXQgYXV0b2NvbXBsZXRlSXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fYXV0b2NvbXBsZXRlSXRlbXM7XG4gICAgICAgIGlmICghaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLmRpc3BsYXlCeV06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLmlkZW50aWZ5QnldOiBpdGVtXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuYW1lIG5nQWZ0ZXJ2aWV3SW5pdFxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5vbkl0ZW1DbGlja2VkKCkuc3Vic2NyaWJlKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBZGRpbmcoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZXNldCBpdGVtc01hdGNoaW5nIGFycmF5IHdoZW4gdGhlIGRyb3Bkb3duIGlzIGhpZGRlblxuICAgICAgICB0aGlzLm9uSGlkZSgpLnN1YnNjcmliZSh0aGlzLnJlc2V0SXRlbXMpO1xuICAgICAgICBjb25zdCBERUJPVU5DRV9USU1FID0gMjAwO1xuICAgICAgICBjb25zdCBLRUVQX09QRU4gPSB0aGlzLmtlZXBPcGVuO1xuICAgICAgICB0aGlzLnRhZ0lucHV0Lm9uVGV4dENoYW5nZVxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShkZWJvdW5jZVRpbWUoREVCT1VOQ0VfVElNRSksIGZpbHRlcigodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChLRUVQX09QRU4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuc2hvdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuYW1lIHVwZGF0ZVBvc2l0aW9uXG4gICAgICovXG4gICAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy50YWdJbnB1dC5pbnB1dEZvcm0uZ2V0RWxlbWVudFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24ubWVudS51cGRhdGVQb3NpdGlvbihwb3NpdGlvbiwgdGhpcy5keW5hbWljVXBkYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5hbWUgaXNWaXNpYmxlXG4gICAgICovXG4gICAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24ubWVudS5kcm9wZG93blN0YXRlLm1lbnVTdGF0ZS5pc1Zpc2libGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuYW1lIG9uSGlkZVxuICAgICAqL1xuICAgIG9uSGlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24ub25IaWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmFtZSBvbkl0ZW1DbGlja2VkXG4gICAgICovXG4gICAgb25JdGVtQ2xpY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24ub25JdGVtQ2xpY2tlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5hbWUgc2VsZWN0ZWRJdGVtXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24ubWVudS5kcm9wZG93blN0YXRlLmRyb3Bkb3duU3RhdGUuc2VsZWN0ZWRJdGVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzdGF0ZVxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24ubWVudS5kcm9wZG93blN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmFtZSBoaWRlXG4gICAgICovXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5yZXNldEl0ZW1zKCk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzY3JvbGxMaXN0ZW5lclxuICAgICAqL1xuICAgIHNjcm9sbExpc3RlbmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlIHx8ICF0aGlzLmR5bmFtaWNVcGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuYW1lIG9uV2luZG93Qmx1clxuICAgICAqL1xuICAgIG9uV2luZG93Qmx1cigpIHtcbiAgICAgICAgdGhpcy5kcm9wZG93bi5oaWRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuYW1lIGdldEZvcm1WYWx1ZVxuICAgICAqL1xuICAgIGdldEZvcm1WYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgZm9ybVZhbHVlID0gdGhpcy50YWdJbnB1dC5mb3JtVmFsdWU7XG4gICAgICAgIHJldHVybiBmb3JtVmFsdWUgPyBmb3JtVmFsdWUudG9TdHJpbmcoKS50cmltKCkgOiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5hbWUgY2FsY3VsYXRlUG9zaXRpb25cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnSW5wdXQuaW5wdXRGb3JtLmdldEVsZW1lbnRQb3NpdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmFtZSBjcmVhdGVUYWdNb2RlbFxuICAgICAqIEBwYXJhbSBpdGVtXG4gICAgICovXG4gICAgY3JlYXRlVGFnTW9kZWwoaXRlbSkge1xuICAgICAgICBjb25zdCBkaXNwbGF5ID0gdHlwZW9mIGl0ZW0udmFsdWUgPT09ICdzdHJpbmcnID8gaXRlbS52YWx1ZSA6IGl0ZW0udmFsdWVbdGhpcy5kaXNwbGF5QnldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBpdGVtLnZhbHVlID09PSAnc3RyaW5nJyA/IGl0ZW0udmFsdWUgOiBpdGVtLnZhbHVlW3RoaXMuaWRlbnRpZnlCeV07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpdGVtLnZhbHVlLCB7IFt0aGlzLnRhZ0lucHV0LmRpc3BsYXlCeV06IGRpc3BsYXksIFt0aGlzLnRhZ0lucHV0LmlkZW50aWZ5QnldOiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRNYXRjaGluZ0l0ZW1zKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgIXRoaXMuc2hvd0Ryb3Bkb3duSWZFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR1cGVzQWxsb3dlZCA9IHRoaXMudGFnSW5wdXQuYWxsb3dEdXBlcztcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b2NvbXBsZXRlSXRlbXMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYXNWYWx1ZSA9IGR1cGVzQWxsb3dlZFxuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMudGFnSW5wdXQudGFncy5zb21lKHRhZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZ5QnkgPSB0aGlzLnRhZ0lucHV0LmlkZW50aWZ5Qnk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdHlwZW9mIHRhZy5tb2RlbCA9PT0gJ3N0cmluZycgPyB0YWcubW9kZWwgOiB0YWcubW9kZWxbaWRlbnRpZnlCeV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbCA9PT0gaXRlbVt0aGlzLmlkZW50aWZ5QnldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hpbmdGbih2YWx1ZSwgaXRlbSkgJiYgaGFzVmFsdWUgPT09IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5hbWUgc2V0SXRlbXNcbiAgICAgKi9cbiAgICBzZXRJdGVtcyhpdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXMuc2xpY2UoMCwgdGhpcy5saW1pdEl0ZW1zVG8gfHwgaXRlbXMubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5hbWUgcG9wdWxhdGVJdGVtc1xuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgcG9wdWxhdGVJdGVtcyhkYXRhKSB7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlSXRlbXMgPSBkYXRhLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuZGlzcGxheUJ5XTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuaWRlbnRpZnlCeV06IGl0ZW1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBuYW1lIHNldExvYWRpbmdTdGF0ZVxuICAgICAqIEBwYXJhbSBzdGF0ZVxuICAgICAqL1xuICAgIHNldExvYWRpbmdTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnRhZ0lucHV0LmlzTG9hZGluZyA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoTmcyRHJvcGRvd24sIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOZzJEcm9wZG93bilcbl0sIFRhZ0lucHV0RHJvcGRvd24ucHJvdG90eXBlLCBcImRyb3Bkb3duXCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihUZW1wbGF0ZVJlZiksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgVGFnSW5wdXREcm9wZG93bi5wcm90b3R5cGUsIFwidGVtcGxhdGVzXCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGFnSW5wdXREcm9wZG93bi5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGFnSW5wdXREcm9wZG93bi5wcm90b3R5cGUsIFwiZm9jdXNGaXJzdEVsZW1lbnRcIiwgdm9pZCAwKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUYWdJbnB1dERyb3Bkb3duLnByb3RvdHlwZSwgXCJzaG93RHJvcGRvd25JZkVtcHR5XCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUYWdJbnB1dERyb3Bkb3duLnByb3RvdHlwZSwgXCJhdXRvY29tcGxldGVPYnNlcnZhYmxlXCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGFnSW5wdXREcm9wZG93bi5wcm90b3R5cGUsIFwibWluaW11bVRleHRMZW5ndGhcIiwgdm9pZCAwKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUYWdJbnB1dERyb3Bkb3duLnByb3RvdHlwZSwgXCJsaW1pdEl0ZW1zVG9cIiwgdm9pZCAwKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUYWdJbnB1dERyb3Bkb3duLnByb3RvdHlwZSwgXCJkaXNwbGF5QnlcIiwgdm9pZCAwKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUYWdJbnB1dERyb3Bkb3duLnByb3RvdHlwZSwgXCJpZGVudGlmeUJ5XCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBUYWdJbnB1dERyb3Bkb3duLnByb3RvdHlwZSwgXCJtYXRjaGluZ0ZuXCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGFnSW5wdXREcm9wZG93bi5wcm90b3R5cGUsIFwiYXBwZW5kVG9Cb2R5XCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGFnSW5wdXREcm9wZG93bi5wcm90b3R5cGUsIFwia2VlcE9wZW5cIiwgdm9pZCAwKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUYWdJbnB1dERyb3Bkb3duLnByb3RvdHlwZSwgXCJkeW5hbWljVXBkYXRlXCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGFnSW5wdXREcm9wZG93bi5wcm90b3R5cGUsIFwiekluZGV4XCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBUYWdJbnB1dERyb3Bkb3duLnByb3RvdHlwZSwgXCJhdXRvY29tcGxldGVJdGVtc1wiLCBudWxsKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCd3aW5kb3c6c2Nyb2xsJyksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBUYWdJbnB1dERyb3Bkb3duLnByb3RvdHlwZSwgXCJzY3JvbGxMaXN0ZW5lclwiLCBudWxsKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSG9zdExpc3RlbmVyKCd3aW5kb3c6Ymx1cicpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgVGFnSW5wdXREcm9wZG93bi5wcm90b3R5cGUsIFwib25XaW5kb3dCbHVyXCIsIG51bGwpO1xuVGFnSW5wdXREcm9wZG93biA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICd0YWctaW5wdXQtZHJvcGRvd24nLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8bmcyLWRyb3Bkb3duIFtkeW5hbWljVXBkYXRlXT1cXFwiZHluYW1pY1VwZGF0ZVxcXCI+XFxuICAgIDxuZzItZHJvcGRvd24tbWVudSBbZm9jdXNGaXJzdEVsZW1lbnRdPVxcXCJmb2N1c0ZpcnN0RWxlbWVudFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgIFt6SW5kZXhdPVxcXCJ6SW5kZXhcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICBbYXBwZW5kVG9Cb2R5XT1cXFwiYXBwZW5kVG9Cb2R5XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgW29mZnNldF09XFxcIm9mZnNldFxcXCI+XFxuICAgICAgICA8bmcyLW1lbnUtaXRlbSAqbmdGb3I9XFxcImxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaW5kZXggPSBpbmRleDsgbGV0IGxhc3QgPSBsYXN0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cXFwiaXRlbVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgIFtuZ1N3aXRjaF09XFxcIiEhdGVtcGxhdGVzLmxlbmd0aFxcXCI+XFxuXFxuICAgICAgICAgICAgPHNwYW4gKm5nU3dpdGNoQ2FzZT1cXFwiZmFsc2VcXFwiXFxuICAgICAgICAgICAgICAgICAgW2lubmVySFRNTF09XFxcIml0ZW1bZGlzcGxheUJ5XSB8IGhpZ2hsaWdodCA6IHRhZ0lucHV0LmlucHV0Rm9ybS52YWx1ZS52YWx1ZVxcXCI+XFxuICAgICAgICAgICAgPC9zcGFuPlxcblxcbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdTd2l0Y2hEZWZhdWx0XFxuICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cXFwidGVtcGxhdGVzLmZpcnN0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVxcXCJ7IGl0ZW06IGl0ZW0sIGluZGV4OiBpbmRleCwgbGFzdDogbGFzdCB9XFxcIj5cXG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgPC9uZzItbWVudS1pdGVtPlxcbiAgICA8L25nMi1kcm9wZG93bi1tZW51PlxcbjwvbmcyLWRyb3Bkb3duPlxcblwiXG4gICAgfSksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0luamVjdG9yXSlcbl0sIFRhZ0lucHV0RHJvcGRvd24pO1xuZXhwb3J0IHsgVGFnSW5wdXREcm9wZG93biB9O1xuIl19