/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Output, EventEmitter, Input, HostBinding, ChangeDetectorRef, ViewChild, ChangeDetectionStrategy } from '@angular/core';
import { ScrollerComponent } from './scroller.component';
import { SelectionType } from '../../types/selection.type';
import { columnsByPin, columnGroupWidths } from '../../utils/column';
import { RowHeightCache } from '../../utils/row-height-cache';
import { translateXY } from '../../utils/translate';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './selection.component';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from './progress-bar.component';
import * as ɵngcc4 from './scroller.component';
import * as ɵngcc5 from './summary/summary-row.component';
import * as ɵngcc6 from './body-row-wrapper.component';
import * as ɵngcc7 from './body-row.component';

function DataTableBodyComponent_datatable_progress_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "datatable-progress");
} }
function DataTableBodyComponent_datatable_scroller_3_datatable_summary_row_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "datatable-summary-row", 9);
} if (rf & 2) {
    var ctx_r272 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("rowHeight", ctx_r272.summaryHeight)("offsetX", ctx_r272.offsetX)("innerWidth", ctx_r272.innerWidth)("rows", ctx_r272.rows)("columns", ctx_r272.columns);
} }
function DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_datatable_body_row_1_Template(rf, ctx) { if (rf & 1) {
    var _r282 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "datatable-body-row", 13);
    ɵngcc0.ɵɵlistener("treeAction", function DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_datatable_body_row_1_Template_datatable_body_row_treeAction_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r282); var group_r275 = ɵngcc0.ɵɵnextContext().$implicit; var ctx_r280 = ɵngcc0.ɵɵnextContext(2); return ctx_r280.onTreeAction(group_r275); })("activate", function DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_datatable_body_row_1_Template_datatable_body_row_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r282); var i_r276 = ɵngcc0.ɵɵnextContext().index; var ctx_r283 = ɵngcc0.ɵɵnextContext(2); var _r268 = ɵngcc0.ɵɵreference(1); return _r268.onActivate($event, ctx_r283.indexes.first + i_r276); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r275 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r277 = ɵngcc0.ɵɵnextContext(2);
    var _r268 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("isSelected", _r268.getRowSelected(group_r275))("innerWidth", ctx_r277.innerWidth)("offsetX", ctx_r277.offsetX)("columns", ctx_r277.columns)("rowHeight", ctx_r277.getRowHeight(group_r275))("row", group_r275)("rowIndex", ctx_r277.getRowIndex(group_r275))("expanded", ctx_r277.getRowExpanded(group_r275))("rowClass", ctx_r277.rowClass)("displayCheck", ctx_r277.displayCheck)("treeStatus", group_r275.treeStatus);
} }
function DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_ng_template_2_datatable_body_row_0_Template(rf, ctx) { if (rf & 1) {
    var _r290 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "datatable-body-row", 15);
    ɵngcc0.ɵɵlistener("activate", function DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_ng_template_2_datatable_body_row_0_Template_datatable_body_row_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r290); var i_r288 = ctx.index; ɵngcc0.ɵɵnextContext(4); var _r268 = ɵngcc0.ɵɵreference(1); return _r268.onActivate($event, i_r288); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var row_r287 = ctx.$implicit;
    var group_r275 = ɵngcc0.ɵɵnextContext(2).$implicit;
    var ctx_r286 = ɵngcc0.ɵɵnextContext(2);
    var _r268 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("isSelected", _r268.getRowSelected(row_r287))("innerWidth", ctx_r286.innerWidth)("offsetX", ctx_r286.offsetX)("columns", ctx_r286.columns)("rowHeight", ctx_r286.getRowHeight(row_r287))("row", row_r287)("group", group_r275.value)("rowIndex", ctx_r286.getRowIndex(row_r287))("expanded", ctx_r286.getRowExpanded(row_r287))("rowClass", ctx_r286.rowClass);
} }
function DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_ng_template_2_datatable_body_row_0_Template, 1, 10, "datatable-body-row", 14);
} if (rf & 2) {
    var group_r275 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r279 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngForOf", group_r275.value)("ngForTrackBy", ctx_r279.rowTrackingFn);
} }
function DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_Template(rf, ctx) { if (rf & 1) {
    var _r294 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "datatable-row-wrapper", 10);
    ɵngcc0.ɵɵlistener("rowContextmenu", function DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_Template_datatable_row_wrapper_rowContextmenu_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r294); var ctx_r293 = ɵngcc0.ɵɵnextContext(2); return ctx_r293.rowContextmenu.emit($event); });
    ɵngcc0.ɵɵtemplate(1, DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_datatable_body_row_1_Template, 1, 11, "datatable-body-row", 11);
    ɵngcc0.ɵɵtemplate(2, DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_ng_template_2_Template, 1, 2, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r275 = ctx.$implicit;
    var i_r276 = ctx.index;
    var _r278 = ɵngcc0.ɵɵreference(3);
    var ctx_r273 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("groupedRows", ctx_r273.groupedRows)("innerWidth", ctx_r273.innerWidth)("ngStyle", ctx_r273.getRowsStyles(group_r275))("rowDetail", ctx_r273.rowDetail)("groupHeader", ctx_r273.groupHeader)("offsetX", ctx_r273.offsetX)("detailRowHeight", ctx_r273.getDetailRowHeight(group_r275[i_r276], i_r276))("row", group_r275)("expanded", ctx_r273.getRowExpanded(group_r275))("rowIndex", ctx_r273.getRowIndex(group_r275[i_r276]));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r273.groupedRows)("ngIfElse", _r278);
} }
function DataTableBodyComponent_datatable_scroller_3_datatable_summary_row_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "datatable-summary-row", 16);
} if (rf & 2) {
    var ctx_r274 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r274.getBottomSummaryRowStyles())("rowHeight", ctx_r274.summaryHeight)("offsetX", ctx_r274.offsetX)("innerWidth", ctx_r274.innerWidth)("rows", ctx_r274.rows)("columns", ctx_r274.columns);
} }
function DataTableBodyComponent_datatable_scroller_3_Template(rf, ctx) { if (rf & 1) {
    var _r296 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "datatable-scroller", 5);
    ɵngcc0.ɵɵlistener("scroll", function DataTableBodyComponent_datatable_scroller_3_Template_datatable_scroller_scroll_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r296); var ctx_r295 = ɵngcc0.ɵɵnextContext(); return ctx_r295.onBodyScroll($event); });
    ɵngcc0.ɵɵtemplate(1, DataTableBodyComponent_datatable_scroller_3_datatable_summary_row_1_Template, 1, 5, "datatable-summary-row", 6);
    ɵngcc0.ɵɵtemplate(2, DataTableBodyComponent_datatable_scroller_3_datatable_row_wrapper_2_Template, 4, 12, "datatable-row-wrapper", 7);
    ɵngcc0.ɵɵtemplate(3, DataTableBodyComponent_datatable_scroller_3_datatable_summary_row_3_Template, 1, 6, "datatable-summary-row", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r270 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("scrollbarV", ctx_r270.scrollbarV)("scrollbarH", ctx_r270.scrollbarH)("scrollHeight", ctx_r270.scrollHeight)("scrollWidth", ctx_r270.columnGroupWidths == null ? null : ctx_r270.columnGroupWidths.total);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r270.summaryRow && ctx_r270.summaryPosition === "top");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r270.temp)("ngForTrackBy", ctx_r270.rowTrackingFn);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r270.summaryRow && ctx_r270.summaryPosition === "bottom");
} }
function DataTableBodyComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 17);
} if (rf & 2) {
    var ctx_r271 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r271.emptyMessage, ɵngcc0.ɵɵsanitizeHtml);
} }
var DataTableBodyComponent = /** @class */ (function () {
    /**
     * Creates an instance of DataTableBodyComponent.
     */
    function DataTableBodyComponent(cd) {
        var _this = this;
        this.cd = cd;
        this.selected = [];
        this.scroll = new EventEmitter();
        this.page = new EventEmitter();
        this.activate = new EventEmitter();
        this.select = new EventEmitter();
        this.detailToggle = new EventEmitter();
        this.rowContextmenu = new EventEmitter(false);
        this.treeAction = new EventEmitter();
        this.rowHeightsCache = new RowHeightCache();
        this.temp = [];
        this.offsetY = 0;
        this.indexes = {};
        this.rowIndexes = new Map();
        this.rowExpansions = [];
        /**
         * Get the height of the detail row.
         */
        this.getDetailRowHeight = (/**
         * @param {?=} row
         * @param {?=} index
         * @return {?}
         */
        function (row, index) {
            if (!_this.rowDetail) {
                return 0;
            }
            /** @type {?} */
            var rowHeight = _this.rowDetail.rowHeight;
            return typeof rowHeight === 'function' ? rowHeight(row, index) : ((/** @type {?} */ (rowHeight)));
        });
        // declare fn here so we can get access to the `this` property
        this.rowTrackingFn = (/**
         * @param {?} index
         * @param {?} row
         * @return {?}
         */
        function (index, row) {
            /** @type {?} */
            var idx = _this.getRowIndex(row);
            if (_this.trackByProp) {
                return row[_this.trackByProp];
            }
            else {
                return idx;
            }
        });
    }
    Object.defineProperty(DataTableBodyComponent.prototype, "pageSize", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pageSize;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._pageSize = val;
            this.recalcLayout();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableBodyComponent.prototype, "rows", {
        get: /**
         * @return {?}
         */
        function () {
            return this._rows;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._rows = val;
            this.recalcLayout();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableBodyComponent.prototype, "columns", {
        get: /**
         * @return {?}
         */
        function () {
            return this._columns;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._columns = val;
            /** @type {?} */
            var colsByPin = columnsByPin(val);
            this.columnGroupWidths = columnGroupWidths(colsByPin, val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableBodyComponent.prototype, "offset", {
        get: /**
         * @return {?}
         */
        function () {
            return this._offset;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._offset = val;
            if (!this.scrollbarV || (this.scrollbarV && !this.virtualization))
                this.recalcLayout();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableBodyComponent.prototype, "rowCount", {
        get: /**
         * @return {?}
         */
        function () {
            return this._rowCount;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._rowCount = val;
            this.recalcLayout();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableBodyComponent.prototype, "bodyWidth", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.scrollbarH) {
                return this.innerWidth + 'px';
            }
            else {
                return '100%';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableBodyComponent.prototype, "bodyHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this._bodyHeight;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (this.scrollbarV) {
                this._bodyHeight = val + 'px';
            }
            else {
                this._bodyHeight = 'auto';
            }
            this.recalcLayout();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableBodyComponent.prototype, "selectEnabled", {
        /**
         * Returns if selection is enabled.
         */
        get: /**
         * Returns if selection is enabled.
         * @return {?}
         */
        function () {
            return !!this.selectionType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableBodyComponent.prototype, "scrollHeight", {
        /**
         * Property that would calculate the height of scroll bar
         * based on the row heights cache for virtual scroll and virtualization. Other scenarios
         * calculate scroll height automatically (as height will be undefined).
         */
        get: /**
         * Property that would calculate the height of scroll bar
         * based on the row heights cache for virtual scroll and virtualization. Other scenarios
         * calculate scroll height automatically (as height will be undefined).
         * @return {?}
         */
        function () {
            if (this.scrollbarV && this.virtualization && this.rowCount) {
                return this.rowHeightsCache.query(this.rowCount - 1);
            }
            // avoid TS7030: Not all code paths return a value.
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called after the constructor, initializing input properties
     */
    /**
     * Called after the constructor, initializing input properties
     * @return {?}
     */
    DataTableBodyComponent.prototype.ngOnInit = /**
     * Called after the constructor, initializing input properties
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.rowDetail) {
            this.listener = this.rowDetail.toggle.subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var type = _a.type, value = _a.value;
                if (type === 'row') {
                    _this.toggleRowExpansion(value);
                }
                if (type === 'all') {
                    _this.toggleAllRows(value);
                }
                // Refresh rows after toggle
                // Fixes #883
                _this.updateIndexes();
                _this.updateRows();
                _this.cd.markForCheck();
            }));
        }
        if (this.groupHeader) {
            this.listener = this.groupHeader.toggle.subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var type = _a.type, value = _a.value;
                if (type === 'group') {
                    _this.toggleRowExpansion(value);
                }
                if (type === 'all') {
                    _this.toggleAllRows(value);
                }
                // Refresh rows after toggle
                // Fixes #883
                _this.updateIndexes();
                _this.updateRows();
                _this.cd.markForCheck();
            }));
        }
    };
    /**
     * Called once, before the instance is destroyed.
     */
    /**
     * Called once, before the instance is destroyed.
     * @return {?}
     */
    DataTableBodyComponent.prototype.ngOnDestroy = /**
     * Called once, before the instance is destroyed.
     * @return {?}
     */
    function () {
        if (this.rowDetail || this.groupHeader) {
            this.listener.unsubscribe();
        }
    };
    /**
     * Updates the Y offset given a new offset.
     */
    /**
     * Updates the Y offset given a new offset.
     * @param {?=} offset
     * @return {?}
     */
    DataTableBodyComponent.prototype.updateOffsetY = /**
     * Updates the Y offset given a new offset.
     * @param {?=} offset
     * @return {?}
     */
    function (offset) {
        // scroller is missing on empty table
        if (!this.scroller) {
            return;
        }
        if (this.scrollbarV && this.virtualization && offset) {
            // First get the row Index that we need to move to.
            /** @type {?} */
            var rowIndex = this.pageSize * offset;
            offset = this.rowHeightsCache.query(rowIndex - 1);
        }
        else if (this.scrollbarV && !this.virtualization) {
            offset = 0;
        }
        this.scroller.setOffset(offset || 0);
    };
    /**
     * Body was scrolled, this is mainly useful for
     * when a user is server-side pagination via virtual scroll.
     */
    /**
     * Body was scrolled, this is mainly useful for
     * when a user is server-side pagination via virtual scroll.
     * @param {?} event
     * @return {?}
     */
    DataTableBodyComponent.prototype.onBodyScroll = /**
     * Body was scrolled, this is mainly useful for
     * when a user is server-side pagination via virtual scroll.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var scrollYPos = event.scrollYPos;
        /** @type {?} */
        var scrollXPos = event.scrollXPos;
        // if scroll change, trigger update
        // this is mainly used for header cell positions
        if (this.offsetY !== scrollYPos || this.offsetX !== scrollXPos) {
            this.scroll.emit({
                offsetY: scrollYPos,
                offsetX: scrollXPos
            });
        }
        this.offsetY = scrollYPos;
        this.offsetX = scrollXPos;
        this.updateIndexes();
        this.updatePage(event.direction);
        this.updateRows();
    };
    /**
     * Updates the page given a direction.
     */
    /**
     * Updates the page given a direction.
     * @param {?} direction
     * @return {?}
     */
    DataTableBodyComponent.prototype.updatePage = /**
     * Updates the page given a direction.
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        /** @type {?} */
        var offset = this.indexes.first / this.pageSize;
        if (direction === 'up') {
            offset = Math.ceil(offset);
        }
        else if (direction === 'down') {
            offset = Math.floor(offset);
        }
        if (direction !== undefined && !isNaN(offset)) {
            this.page.emit({ offset: offset });
        }
    };
    /**
     * Updates the rows in the view port
     */
    /**
     * Updates the rows in the view port
     * @return {?}
     */
    DataTableBodyComponent.prototype.updateRows = /**
     * Updates the rows in the view port
     * @return {?}
     */
    function () {
        var _a = this.indexes, first = _a.first, last = _a.last;
        /** @type {?} */
        var rowIndex = first;
        /** @type {?} */
        var idx = 0;
        /** @type {?} */
        var temp = [];
        this.rowIndexes.clear();
        // if grouprowsby has been specified treat row paging
        // parameters as group paging parameters ie if limit 10 has been
        // specified treat it as 10 groups rather than 10 rows
        if (this.groupedRows) {
            /** @type {?} */
            var maxRowsPerGroup = 3;
            // if there is only one group set the maximum number of
            // rows per group the same as the total number of rows
            if (this.groupedRows.length === 1) {
                maxRowsPerGroup = this.groupedRows[0].value.length;
            }
            while (rowIndex < last && rowIndex < this.groupedRows.length) {
                // Add the groups into this page
                /** @type {?} */
                var group = this.groupedRows[rowIndex];
                temp[idx] = group;
                idx++;
                // Group index in this context
                rowIndex++;
            }
        }
        else {
            while (rowIndex < last && rowIndex < this.rowCount) {
                /** @type {?} */
                var row = this.rows[rowIndex];
                if (row) {
                    this.rowIndexes.set(row, rowIndex);
                    temp[idx] = row;
                }
                idx++;
                rowIndex++;
            }
        }
        this.temp = temp;
    };
    /**
     * Get the row height
     */
    /**
     * Get the row height
     * @param {?} row
     * @return {?}
     */
    DataTableBodyComponent.prototype.getRowHeight = /**
     * Get the row height
     * @param {?} row
     * @return {?}
     */
    function (row) {
        // if its a function return it
        if (typeof this.rowHeight === 'function') {
            return this.rowHeight(row);
        }
        return (/** @type {?} */ (this.rowHeight));
    };
    /**
     * @param group the group with all rows
     */
    /**
     * @param {?} group the group with all rows
     * @return {?}
     */
    DataTableBodyComponent.prototype.getGroupHeight = /**
     * @param {?} group the group with all rows
     * @return {?}
     */
    function (group) {
        /** @type {?} */
        var rowHeight = 0;
        if (group.value) {
            for (var index = 0; index < group.value.length; index++) {
                rowHeight += this.getRowAndDetailHeight(group.value[index]);
            }
        }
        return rowHeight;
    };
    /**
     * Calculate row height based on the expanded state of the row.
     */
    /**
     * Calculate row height based on the expanded state of the row.
     * @param {?} row
     * @return {?}
     */
    DataTableBodyComponent.prototype.getRowAndDetailHeight = /**
     * Calculate row height based on the expanded state of the row.
     * @param {?} row
     * @return {?}
     */
    function (row) {
        /** @type {?} */
        var rowHeight = this.getRowHeight(row);
        /** @type {?} */
        var expanded = this.getRowExpanded(row);
        // Adding detail row height if its expanded.
        if (expanded) {
            rowHeight += this.getDetailRowHeight(row);
        }
        return rowHeight;
    };
    /**
     * Calculates the styles for the row so that the rows can be moved in 2D space
     * during virtual scroll inside the DOM.   In the below case the Y position is
     * manipulated.   As an example, if the height of row 0 is 30 px and row 1 is
     * 100 px then following styles are generated:
     *
     * transform: translate3d(0px, 0px, 0px);    ->  row0
     * transform: translate3d(0px, 30px, 0px);   ->  row1
     * transform: translate3d(0px, 130px, 0px);  ->  row2
     *
     * Row heights have to be calculated based on the row heights cache as we wont
     * be able to determine which row is of what height before hand.  In the above
     * case the positionY of the translate3d for row2 would be the sum of all the
     * heights of the rows before it (i.e. row0 and row1).
     *
     * @param rows the row that needs to be placed in the 2D space.
     * @returns the CSS3 style to be applied
     *
     * @memberOf DataTableBodyComponent
     */
    /**
     * Calculates the styles for the row so that the rows can be moved in 2D space
     * during virtual scroll inside the DOM.   In the below case the Y position is
     * manipulated.   As an example, if the height of row 0 is 30 px and row 1 is
     * 100 px then following styles are generated:
     *
     * transform: translate3d(0px, 0px, 0px);    ->  row0
     * transform: translate3d(0px, 30px, 0px);   ->  row1
     * transform: translate3d(0px, 130px, 0px);  ->  row2
     *
     * Row heights have to be calculated based on the row heights cache as we wont
     * be able to determine which row is of what height before hand.  In the above
     * case the positionY of the translate3d for row2 would be the sum of all the
     * heights of the rows before it (i.e. row0 and row1).
     *
     * \@memberOf DataTableBodyComponent
     * @param {?} rows the row that needs to be placed in the 2D space.
     * @return {?} the CSS3 style to be applied
     *
     */
    DataTableBodyComponent.prototype.getRowsStyles = /**
     * Calculates the styles for the row so that the rows can be moved in 2D space
     * during virtual scroll inside the DOM.   In the below case the Y position is
     * manipulated.   As an example, if the height of row 0 is 30 px and row 1 is
     * 100 px then following styles are generated:
     *
     * transform: translate3d(0px, 0px, 0px);    ->  row0
     * transform: translate3d(0px, 30px, 0px);   ->  row1
     * transform: translate3d(0px, 130px, 0px);  ->  row2
     *
     * Row heights have to be calculated based on the row heights cache as we wont
     * be able to determine which row is of what height before hand.  In the above
     * case the positionY of the translate3d for row2 would be the sum of all the
     * heights of the rows before it (i.e. row0 and row1).
     *
     * \@memberOf DataTableBodyComponent
     * @param {?} rows the row that needs to be placed in the 2D space.
     * @return {?} the CSS3 style to be applied
     *
     */
    function (rows) {
        /** @type {?} */
        var styles = {};
        // only add styles for the group if there is a group
        if (this.groupedRows) {
            styles.width = this.columnGroupWidths.total;
        }
        if (this.scrollbarV && this.virtualization) {
            /** @type {?} */
            var idx = 0;
            if (this.groupedRows) {
                // Get the latest row rowindex in a group
                /** @type {?} */
                var row = rows[rows.length - 1];
                idx = row ? this.getRowIndex(row) : 0;
            }
            else {
                idx = this.getRowIndex(rows);
            }
            // const pos = idx * rowHeight;
            // The position of this row would be the sum of all row heights
            // until the previous row position.
            /** @type {?} */
            var pos = this.rowHeightsCache.query(idx - 1);
            translateXY(styles, 0, pos);
        }
        return styles;
    };
    /**
     * Calculate bottom summary row offset for scrollbar mode.
     * For more information about cache and offset calculation
     * see description for `getRowsStyles` method
     *
     * @returns the CSS3 style to be applied
     *
     * @memberOf DataTableBodyComponent
     */
    /**
     * Calculate bottom summary row offset for scrollbar mode.
     * For more information about cache and offset calculation
     * see description for `getRowsStyles` method
     *
     * \@memberOf DataTableBodyComponent
     * @return {?} the CSS3 style to be applied
     *
     */
    DataTableBodyComponent.prototype.getBottomSummaryRowStyles = /**
     * Calculate bottom summary row offset for scrollbar mode.
     * For more information about cache and offset calculation
     * see description for `getRowsStyles` method
     *
     * \@memberOf DataTableBodyComponent
     * @return {?} the CSS3 style to be applied
     *
     */
    function () {
        if (!this.scrollbarV || !this.rows || !this.rows.length) {
            return null;
        }
        /** @type {?} */
        var styles = { position: 'absolute' };
        /** @type {?} */
        var pos = this.rowHeightsCache.query(this.rows.length - 1);
        translateXY(styles, 0, pos);
        return styles;
    };
    /**
     * Hides the loading indicator
     */
    /**
     * Hides the loading indicator
     * @return {?}
     */
    DataTableBodyComponent.prototype.hideIndicator = /**
     * Hides the loading indicator
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout((/**
         * @return {?}
         */
        function () { return (_this.loadingIndicator = false); }), 500);
    };
    /**
     * Updates the index of the rows in the viewport
     */
    /**
     * Updates the index of the rows in the viewport
     * @return {?}
     */
    DataTableBodyComponent.prototype.updateIndexes = /**
     * Updates the index of the rows in the viewport
     * @return {?}
     */
    function () {
        /** @type {?} */
        var first = 0;
        /** @type {?} */
        var last = 0;
        if (this.scrollbarV) {
            if (this.virtualization) {
                // Calculation of the first and last indexes will be based on where the
                // scrollY position would be at.  The last index would be the one
                // that shows up inside the view port the last.
                /** @type {?} */
                var height = parseInt(this.bodyHeight, 0);
                first = this.rowHeightsCache.getRowIndex(this.offsetY);
                last = this.rowHeightsCache.getRowIndex(height + this.offsetY) + 1;
            }
            else {
                // If virtual rows are not needed
                // We render all in one go
                first = 0;
                last = this.rowCount;
            }
        }
        else {
            // The server is handling paging and will pass an array that begins with the
            // element at a specified offset.  first should always be 0 with external paging.
            if (!this.externalPaging) {
                first = Math.max(this.offset * this.pageSize, 0);
            }
            last = Math.min(first + this.pageSize, this.rowCount);
        }
        this.indexes = { first: first, last: last };
    };
    /**
     * Refreshes the full Row Height cache.  Should be used
     * when the entire row array state has changed.
     */
    /**
     * Refreshes the full Row Height cache.  Should be used
     * when the entire row array state has changed.
     * @return {?}
     */
    DataTableBodyComponent.prototype.refreshRowHeightCache = /**
     * Refreshes the full Row Height cache.  Should be used
     * when the entire row array state has changed.
     * @return {?}
     */
    function () {
        var e_1, _a;
        if (!this.scrollbarV || (this.scrollbarV && !this.virtualization)) {
            return;
        }
        // clear the previous row height cache if already present.
        // this is useful during sorts, filters where the state of the
        // rows array is changed.
        this.rowHeightsCache.clearCache();
        // Initialize the tree only if there are rows inside the tree.
        if (this.rows && this.rows.length) {
            /** @type {?} */
            var rowExpansions = new Set();
            try {
                for (var _b = tslib_1.__values(this.rows), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var row = _c.value;
                    if (this.getRowExpanded(row)) {
                        rowExpansions.add(row);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.rowHeightsCache.initCache({
                rows: this.rows,
                rowHeight: this.rowHeight,
                detailRowHeight: this.getDetailRowHeight,
                externalVirtual: this.scrollbarV && this.externalPaging,
                rowCount: this.rowCount,
                rowIndexes: this.rowIndexes,
                rowExpansions: rowExpansions
            });
        }
    };
    /**
     * Gets the index for the view port
     */
    /**
     * Gets the index for the view port
     * @return {?}
     */
    DataTableBodyComponent.prototype.getAdjustedViewPortIndex = /**
     * Gets the index for the view port
     * @return {?}
     */
    function () {
        // Capture the row index of the first row that is visible on the viewport.
        // If the scroll bar is just below the row which is highlighted then make that as the
        // first index.
        /** @type {?} */
        var viewPortFirstRowIndex = this.indexes.first;
        if (this.scrollbarV && this.virtualization) {
            /** @type {?} */
            var offsetScroll = this.rowHeightsCache.query(viewPortFirstRowIndex - 1);
            return offsetScroll <= this.offsetY ? viewPortFirstRowIndex - 1 : viewPortFirstRowIndex;
        }
        return viewPortFirstRowIndex;
    };
    /**
     * Toggle the Expansion of the row i.e. if the row is expanded then it will
     * collapse and vice versa.   Note that the expanded status is stored as
     * a part of the row object itself as we have to preserve the expanded row
     * status in case of sorting and filtering of the row set.
     */
    /**
     * Toggle the Expansion of the row i.e. if the row is expanded then it will
     * collapse and vice versa.   Note that the expanded status is stored as
     * a part of the row object itself as we have to preserve the expanded row
     * status in case of sorting and filtering of the row set.
     * @param {?} row
     * @return {?}
     */
    DataTableBodyComponent.prototype.toggleRowExpansion = /**
     * Toggle the Expansion of the row i.e. if the row is expanded then it will
     * collapse and vice versa.   Note that the expanded status is stored as
     * a part of the row object itself as we have to preserve the expanded row
     * status in case of sorting and filtering of the row set.
     * @param {?} row
     * @return {?}
     */
    function (row) {
        // Capture the row index of the first row that is visible on the viewport.
        /** @type {?} */
        var viewPortFirstRowIndex = this.getAdjustedViewPortIndex();
        /** @type {?} */
        var rowExpandedIdx = this.getRowExpandedIdx(row, this.rowExpansions);
        /** @type {?} */
        var expanded = rowExpandedIdx > -1;
        // If the detailRowHeight is auto --> only in case of non-virtualized scroll
        if (this.scrollbarV && this.virtualization) {
            /** @type {?} */
            var detailRowHeight = this.getDetailRowHeight(row) * (expanded ? -1 : 1);
            // const idx = this.rowIndexes.get(row) || 0;
            /** @type {?} */
            var idx = this.getRowIndex(row);
            this.rowHeightsCache.update(idx, detailRowHeight);
        }
        // Update the toggled row and update thive nevere heights in the cache.
        if (expanded) {
            this.rowExpansions.splice(rowExpandedIdx, 1);
        }
        else {
            this.rowExpansions.push(row);
        }
        this.detailToggle.emit({
            rows: [row],
            currentIndex: viewPortFirstRowIndex
        });
    };
    /**
     * Expand/Collapse all the rows no matter what their state is.
     */
    /**
     * Expand/Collapse all the rows no matter what their state is.
     * @param {?} expanded
     * @return {?}
     */
    DataTableBodyComponent.prototype.toggleAllRows = /**
     * Expand/Collapse all the rows no matter what their state is.
     * @param {?} expanded
     * @return {?}
     */
    function (expanded) {
        var e_2, _a;
        // clear prev expansions
        this.rowExpansions = [];
        // Capture the row index of the first row that is visible on the viewport.
        /** @type {?} */
        var viewPortFirstRowIndex = this.getAdjustedViewPortIndex();
        if (expanded) {
            try {
                for (var _b = tslib_1.__values(this.rows), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var row = _c.value;
                    this.rowExpansions.push(row);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        if (this.scrollbarV) {
            // Refresh the full row heights cache since every row was affected.
            this.recalcLayout();
        }
        // Emit all rows that have been expanded.
        this.detailToggle.emit({
            rows: this.rows,
            currentIndex: viewPortFirstRowIndex
        });
    };
    /**
     * Recalculates the table
     */
    /**
     * Recalculates the table
     * @return {?}
     */
    DataTableBodyComponent.prototype.recalcLayout = /**
     * Recalculates the table
     * @return {?}
     */
    function () {
        this.refreshRowHeightCache();
        this.updateIndexes();
        this.updateRows();
    };
    /**
     * Tracks the column
     */
    /**
     * Tracks the column
     * @param {?} index
     * @param {?} column
     * @return {?}
     */
    DataTableBodyComponent.prototype.columnTrackingFn = /**
     * Tracks the column
     * @param {?} index
     * @param {?} column
     * @return {?}
     */
    function (index, column) {
        return column.$$id;
    };
    /**
     * Gets the row pinning group styles
     */
    /**
     * Gets the row pinning group styles
     * @param {?} group
     * @return {?}
     */
    DataTableBodyComponent.prototype.stylesByGroup = /**
     * Gets the row pinning group styles
     * @param {?} group
     * @return {?}
     */
    function (group) {
        /** @type {?} */
        var widths = this.columnGroupWidths;
        /** @type {?} */
        var offsetX = this.offsetX;
        /** @type {?} */
        var styles = {
            width: widths[group] + "px"
        };
        if (group === 'left') {
            translateXY(styles, offsetX, 0);
        }
        else if (group === 'right') {
            /** @type {?} */
            var bodyWidth = parseInt(this.innerWidth + '', 0);
            /** @type {?} */
            var totalDiff = widths.total - bodyWidth;
            /** @type {?} */
            var offsetDiff = totalDiff - offsetX;
            /** @type {?} */
            var offset = offsetDiff * -1;
            translateXY(styles, offset, 0);
        }
        return styles;
    };
    /**
     * Returns if the row was expanded and set default row expansion when row expansion is empty
     */
    /**
     * Returns if the row was expanded and set default row expansion when row expansion is empty
     * @param {?} row
     * @return {?}
     */
    DataTableBodyComponent.prototype.getRowExpanded = /**
     * Returns if the row was expanded and set default row expansion when row expansion is empty
     * @param {?} row
     * @return {?}
     */
    function (row) {
        var e_3, _a;
        if (this.rowExpansions.length === 0 && this.groupExpansionDefault) {
            try {
                for (var _b = tslib_1.__values(this.groupedRows), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    this.rowExpansions.push(group);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        return this.getRowExpandedIdx(row, this.rowExpansions) > -1;
    };
    /**
     * @param {?} row
     * @param {?} expanded
     * @return {?}
     */
    DataTableBodyComponent.prototype.getRowExpandedIdx = /**
     * @param {?} row
     * @param {?} expanded
     * @return {?}
     */
    function (row, expanded) {
        var _this = this;
        if (!expanded || !expanded.length)
            return -1;
        /** @type {?} */
        var rowId = this.rowIdentity(row);
        return expanded.findIndex((/**
         * @param {?} r
         * @return {?}
         */
        function (r) {
            /** @type {?} */
            var id = _this.rowIdentity(r);
            return id === rowId;
        }));
    };
    /**
     * Gets the row index given a row
     */
    /**
     * Gets the row index given a row
     * @param {?} row
     * @return {?}
     */
    DataTableBodyComponent.prototype.getRowIndex = /**
     * Gets the row index given a row
     * @param {?} row
     * @return {?}
     */
    function (row) {
        return this.rowIndexes.get(row) || 0;
    };
    /**
     * @param {?} row
     * @return {?}
     */
    DataTableBodyComponent.prototype.onTreeAction = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        this.treeAction.emit({ row: row });
    };
    /** @nocollapse */
    DataTableBodyComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    DataTableBodyComponent.propDecorators = {
        scrollbarV: [{ type: Input }],
        scrollbarH: [{ type: Input }],
        loadingIndicator: [{ type: Input }],
        externalPaging: [{ type: Input }],
        rowHeight: [{ type: Input }],
        offsetX: [{ type: Input }],
        emptyMessage: [{ type: Input }],
        selectionType: [{ type: Input }],
        selected: [{ type: Input }],
        rowIdentity: [{ type: Input }],
        rowDetail: [{ type: Input }],
        groupHeader: [{ type: Input }],
        selectCheck: [{ type: Input }],
        displayCheck: [{ type: Input }],
        trackByProp: [{ type: Input }],
        rowClass: [{ type: Input }],
        groupedRows: [{ type: Input }],
        groupExpansionDefault: [{ type: Input }],
        innerWidth: [{ type: Input }],
        groupRowsBy: [{ type: Input }],
        virtualization: [{ type: Input }],
        summaryRow: [{ type: Input }],
        summaryPosition: [{ type: Input }],
        summaryHeight: [{ type: Input }],
        pageSize: [{ type: Input }],
        rows: [{ type: Input }],
        columns: [{ type: Input }],
        offset: [{ type: Input }],
        rowCount: [{ type: Input }],
        bodyWidth: [{ type: HostBinding, args: ['style.width',] }],
        bodyHeight: [{ type: Input }, { type: HostBinding, args: ['style.height',] }],
        scroll: [{ type: Output }],
        page: [{ type: Output }],
        activate: [{ type: Output }],
        select: [{ type: Output }],
        detailToggle: [{ type: Output }],
        rowContextmenu: [{ type: Output }],
        treeAction: [{ type: Output }],
        scroller: [{ type: ViewChild, args: [ScrollerComponent, { static: false },] }]
    };
DataTableBodyComponent.ɵfac = function DataTableBodyComponent_Factory(t) { return new (t || DataTableBodyComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
DataTableBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DataTableBodyComponent, selectors: [["datatable-body"]], viewQuery: function DataTableBodyComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(ScrollerComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scroller = _t.first);
    } }, hostAttrs: [1, "datatable-body"], hostVars: 4, hostBindings: function DataTableBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.bodyWidth)("height", ctx.bodyHeight);
    } }, inputs: { selected: "selected", pageSize: "pageSize", rows: "rows", columns: "columns", offset: "offset", rowCount: "rowCount", bodyHeight: "bodyHeight", offsetX: "offsetX", scrollbarV: "scrollbarV", scrollbarH: "scrollbarH", loadingIndicator: "loadingIndicator", externalPaging: "externalPaging", rowHeight: "rowHeight", emptyMessage: "emptyMessage", selectionType: "selectionType", rowIdentity: "rowIdentity", rowDetail: "rowDetail", groupHeader: "groupHeader", selectCheck: "selectCheck", displayCheck: "displayCheck", trackByProp: "trackByProp", rowClass: "rowClass", groupedRows: "groupedRows", groupExpansionDefault: "groupExpansionDefault", innerWidth: "innerWidth", groupRowsBy: "groupRowsBy", virtualization: "virtualization", summaryRow: "summaryRow", summaryPosition: "summaryPosition", summaryHeight: "summaryHeight" }, outputs: { scroll: "scroll", page: "page", activate: "activate", select: "select", detailToggle: "detailToggle", rowContextmenu: "rowContextmenu", treeAction: "treeAction" }, decls: 5, vars: 9, consts: [[3, "selected", "rows", "selectCheck", "selectEnabled", "selectionType", "rowIdentity", "select", "activate"], ["selector", ""], [4, "ngIf"], [3, "scrollbarV", "scrollbarH", "scrollHeight", "scrollWidth", "scroll", 4, "ngIf"], ["class", "empty-row", 3, "innerHTML", 4, "ngIf"], [3, "scrollbarV", "scrollbarH", "scrollHeight", "scrollWidth", "scroll"], [3, "rowHeight", "offsetX", "innerWidth", "rows", "columns", 4, "ngIf"], [3, "groupedRows", "innerWidth", "ngStyle", "rowDetail", "groupHeader", "offsetX", "detailRowHeight", "row", "expanded", "rowIndex", "rowContextmenu", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngStyle", "rowHeight", "offsetX", "innerWidth", "rows", "columns", 4, "ngIf"], [3, "rowHeight", "offsetX", "innerWidth", "rows", "columns"], [3, "groupedRows", "innerWidth", "ngStyle", "rowDetail", "groupHeader", "offsetX", "detailRowHeight", "row", "expanded", "rowIndex", "rowContextmenu"], ["tabindex", "-1", 3, "isSelected", "innerWidth", "offsetX", "columns", "rowHeight", "row", "rowIndex", "expanded", "rowClass", "displayCheck", "treeStatus", "treeAction", "activate", 4, "ngIf", "ngIfElse"], ["groupedRowsTemplate", ""], ["tabindex", "-1", 3, "isSelected", "innerWidth", "offsetX", "columns", "rowHeight", "row", "rowIndex", "expanded", "rowClass", "displayCheck", "treeStatus", "treeAction", "activate"], ["tabindex", "-1", 3, "isSelected", "innerWidth", "offsetX", "columns", "rowHeight", "row", "group", "rowIndex", "expanded", "rowClass", "activate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["tabindex", "-1", 3, "isSelected", "innerWidth", "offsetX", "columns", "rowHeight", "row", "group", "rowIndex", "expanded", "rowClass", "activate"], [3, "ngStyle", "rowHeight", "offsetX", "innerWidth", "rows", "columns"], [1, "empty-row", 3, "innerHTML"]], template: function DataTableBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "datatable-selection", 0, 1);
        ɵngcc0.ɵɵlistener("select", function DataTableBodyComponent_Template_datatable_selection_select_0_listener($event) { return ctx.select.emit($event); })("activate", function DataTableBodyComponent_Template_datatable_selection_activate_0_listener($event) { return ctx.activate.emit($event); });
        ɵngcc0.ɵɵtemplate(2, DataTableBodyComponent_datatable_progress_2_Template, 1, 0, "datatable-progress", 2);
        ɵngcc0.ɵɵtemplate(3, DataTableBodyComponent_datatable_scroller_3_Template, 4, 8, "datatable-scroller", 3);
        ɵngcc0.ɵɵtemplate(4, DataTableBodyComponent_div_4_Template, 1, 1, "div", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("selected", ctx.selected)("rows", ctx.rows)("selectCheck", ctx.selectCheck)("selectEnabled", ctx.selectEnabled)("selectionType", ctx.selectionType)("rowIdentity", ctx.rowIdentity);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.loadingIndicator);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rows == null ? null : ctx.rows.length);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !(ctx.rows == null ? null : ctx.rows.length) && !ctx.loadingIndicator);
    } }, directives: [ɵngcc1.DataTableSelectionComponent, ɵngcc2.NgIf, ɵngcc3.ProgressBarComponent, ɵngcc4.ScrollerComponent, ɵngcc2.NgForOf, ɵngcc5.DataTableSummaryRowComponent, ɵngcc6.DataTableRowWrapperComponent, ɵngcc2.NgStyle, ɵngcc7.DataTableBodyRowComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DataTableBodyComponent, [{
        type: Component,
        args: [{
                selector: 'datatable-body',
                template: "\n    <datatable-selection\n      #selector\n      [selected]=\"selected\"\n      [rows]=\"rows\"\n      [selectCheck]=\"selectCheck\"\n      [selectEnabled]=\"selectEnabled\"\n      [selectionType]=\"selectionType\"\n      [rowIdentity]=\"rowIdentity\"\n      (select)=\"select.emit($event)\"\n      (activate)=\"activate.emit($event)\"\n    >\n      <datatable-progress *ngIf=\"loadingIndicator\"> </datatable-progress>\n      <datatable-scroller\n        *ngIf=\"rows?.length\"\n        [scrollbarV]=\"scrollbarV\"\n        [scrollbarH]=\"scrollbarH\"\n        [scrollHeight]=\"scrollHeight\"\n        [scrollWidth]=\"columnGroupWidths?.total\"\n        (scroll)=\"onBodyScroll($event)\"\n      >\n        <datatable-summary-row\n          *ngIf=\"summaryRow && summaryPosition === 'top'\"\n          [rowHeight]=\"summaryHeight\"\n          [offsetX]=\"offsetX\"\n          [innerWidth]=\"innerWidth\"\n          [rows]=\"rows\"\n          [columns]=\"columns\"\n        >\n        </datatable-summary-row>\n        <datatable-row-wrapper\n          [groupedRows]=\"groupedRows\"\n          *ngFor=\"let group of temp; let i = index; trackBy: rowTrackingFn\"\n          [innerWidth]=\"innerWidth\"\n          [ngStyle]=\"getRowsStyles(group)\"\n          [rowDetail]=\"rowDetail\"\n          [groupHeader]=\"groupHeader\"\n          [offsetX]=\"offsetX\"\n          [detailRowHeight]=\"getDetailRowHeight(group[i], i)\"\n          [row]=\"group\"\n          [expanded]=\"getRowExpanded(group)\"\n          [rowIndex]=\"getRowIndex(group[i])\"\n          (rowContextmenu)=\"rowContextmenu.emit($event)\"\n        >\n          <datatable-body-row\n            *ngIf=\"!groupedRows; else groupedRowsTemplate\"\n            tabindex=\"-1\"\n            [isSelected]=\"selector.getRowSelected(group)\"\n            [innerWidth]=\"innerWidth\"\n            [offsetX]=\"offsetX\"\n            [columns]=\"columns\"\n            [rowHeight]=\"getRowHeight(group)\"\n            [row]=\"group\"\n            [rowIndex]=\"getRowIndex(group)\"\n            [expanded]=\"getRowExpanded(group)\"\n            [rowClass]=\"rowClass\"\n            [displayCheck]=\"displayCheck\"\n            [treeStatus]=\"group.treeStatus\"\n            (treeAction)=\"onTreeAction(group)\"\n            (activate)=\"selector.onActivate($event, indexes.first + i)\"\n          >\n          </datatable-body-row>\n          <ng-template #groupedRowsTemplate>\n            <datatable-body-row\n              *ngFor=\"let row of group.value; let i = index; trackBy: rowTrackingFn\"\n              tabindex=\"-1\"\n              [isSelected]=\"selector.getRowSelected(row)\"\n              [innerWidth]=\"innerWidth\"\n              [offsetX]=\"offsetX\"\n              [columns]=\"columns\"\n              [rowHeight]=\"getRowHeight(row)\"\n              [row]=\"row\"\n              [group]=\"group.value\"\n              [rowIndex]=\"getRowIndex(row)\"\n              [expanded]=\"getRowExpanded(row)\"\n              [rowClass]=\"rowClass\"\n              (activate)=\"selector.onActivate($event, i)\"\n            >\n            </datatable-body-row>\n          </ng-template>\n        </datatable-row-wrapper>\n        <datatable-summary-row\n          *ngIf=\"summaryRow && summaryPosition === 'bottom'\"\n          [ngStyle]=\"getBottomSummaryRowStyles()\"\n          [rowHeight]=\"summaryHeight\"\n          [offsetX]=\"offsetX\"\n          [innerWidth]=\"innerWidth\"\n          [rows]=\"rows\"\n          [columns]=\"columns\"\n        >\n        </datatable-summary-row>\n      </datatable-scroller>\n      <div class=\"empty-row\" *ngIf=\"!rows?.length && !loadingIndicator\" [innerHTML]=\"emptyMessage\"></div>\n    </datatable-selection>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    class: 'datatable-body'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { selected: [{
            type: Input
        }], scroll: [{
            type: Output
        }], page: [{
            type: Output
        }], activate: [{
            type: Output
        }], select: [{
            type: Output
        }], detailToggle: [{
            type: Output
        }], rowContextmenu: [{
            type: Output
        }], treeAction: [{
            type: Output
        }], pageSize: [{
            type: Input
        }], rows: [{
            type: Input
        }], columns: [{
            type: Input
        }], offset: [{
            type: Input
        }], rowCount: [{
            type: Input
        }], bodyWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], bodyHeight: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['style.height']
        }], offsetX: [{
            type: Input
        }], scrollbarV: [{
            type: Input
        }], scrollbarH: [{
            type: Input
        }], loadingIndicator: [{
            type: Input
        }], externalPaging: [{
            type: Input
        }], rowHeight: [{
            type: Input
        }], emptyMessage: [{
            type: Input
        }], selectionType: [{
            type: Input
        }], rowIdentity: [{
            type: Input
        }], rowDetail: [{
            type: Input
        }], groupHeader: [{
            type: Input
        }], selectCheck: [{
            type: Input
        }], displayCheck: [{
            type: Input
        }], trackByProp: [{
            type: Input
        }], rowClass: [{
            type: Input
        }], groupedRows: [{
            type: Input
        }], groupExpansionDefault: [{
            type: Input
        }], innerWidth: [{
            type: Input
        }], groupRowsBy: [{
            type: Input
        }], virtualization: [{
            type: Input
        }], summaryRow: [{
            type: Input
        }], summaryPosition: [{
            type: Input
        }], summaryHeight: [{
            type: Input
        }], scroller: [{
            type: ViewChild,
            args: [ScrollerComponent, { static: false }]
        }] }); })();
    return DataTableBodyComponent;
}());
export { DataTableBodyComponent };
if (false) {
    /** @type {?} */
    DataTableBodyComponent.prototype.scrollbarV;
    /** @type {?} */
    DataTableBodyComponent.prototype.scrollbarH;
    /** @type {?} */
    DataTableBodyComponent.prototype.loadingIndicator;
    /** @type {?} */
    DataTableBodyComponent.prototype.externalPaging;
    /** @type {?} */
    DataTableBodyComponent.prototype.rowHeight;
    /** @type {?} */
    DataTableBodyComponent.prototype.offsetX;
    /** @type {?} */
    DataTableBodyComponent.prototype.emptyMessage;
    /** @type {?} */
    DataTableBodyComponent.prototype.selectionType;
    /** @type {?} */
    DataTableBodyComponent.prototype.selected;
    /** @type {?} */
    DataTableBodyComponent.prototype.rowIdentity;
    /** @type {?} */
    DataTableBodyComponent.prototype.rowDetail;
    /** @type {?} */
    DataTableBodyComponent.prototype.groupHeader;
    /** @type {?} */
    DataTableBodyComponent.prototype.selectCheck;
    /** @type {?} */
    DataTableBodyComponent.prototype.displayCheck;
    /** @type {?} */
    DataTableBodyComponent.prototype.trackByProp;
    /** @type {?} */
    DataTableBodyComponent.prototype.rowClass;
    /** @type {?} */
    DataTableBodyComponent.prototype.groupedRows;
    /** @type {?} */
    DataTableBodyComponent.prototype.groupExpansionDefault;
    /** @type {?} */
    DataTableBodyComponent.prototype.innerWidth;
    /** @type {?} */
    DataTableBodyComponent.prototype.groupRowsBy;
    /** @type {?} */
    DataTableBodyComponent.prototype.virtualization;
    /** @type {?} */
    DataTableBodyComponent.prototype.summaryRow;
    /** @type {?} */
    DataTableBodyComponent.prototype.summaryPosition;
    /** @type {?} */
    DataTableBodyComponent.prototype.summaryHeight;
    /** @type {?} */
    DataTableBodyComponent.prototype.scroll;
    /** @type {?} */
    DataTableBodyComponent.prototype.page;
    /** @type {?} */
    DataTableBodyComponent.prototype.activate;
    /** @type {?} */
    DataTableBodyComponent.prototype.select;
    /** @type {?} */
    DataTableBodyComponent.prototype.detailToggle;
    /** @type {?} */
    DataTableBodyComponent.prototype.rowContextmenu;
    /** @type {?} */
    DataTableBodyComponent.prototype.treeAction;
    /** @type {?} */
    DataTableBodyComponent.prototype.scroller;
    /** @type {?} */
    DataTableBodyComponent.prototype.rowHeightsCache;
    /** @type {?} */
    DataTableBodyComponent.prototype.temp;
    /** @type {?} */
    DataTableBodyComponent.prototype.offsetY;
    /** @type {?} */
    DataTableBodyComponent.prototype.indexes;
    /** @type {?} */
    DataTableBodyComponent.prototype.columnGroupWidths;
    /** @type {?} */
    DataTableBodyComponent.prototype.columnGroupWidthsWithoutGroup;
    /** @type {?} */
    DataTableBodyComponent.prototype.rowTrackingFn;
    /** @type {?} */
    DataTableBodyComponent.prototype.listener;
    /** @type {?} */
    DataTableBodyComponent.prototype.rowIndexes;
    /** @type {?} */
    DataTableBodyComponent.prototype.rowExpansions;
    /** @type {?} */
    DataTableBodyComponent.prototype._rows;
    /** @type {?} */
    DataTableBodyComponent.prototype._bodyHeight;
    /** @type {?} */
    DataTableBodyComponent.prototype._columns;
    /** @type {?} */
    DataTableBodyComponent.prototype._rowCount;
    /** @type {?} */
    DataTableBodyComponent.prototype._offset;
    /** @type {?} */
    DataTableBodyComponent.prototype._pageSize;
    /**
     * Get the height of the detail row.
     * @type {?}
     */
    DataTableBodyComponent.prototype.getDetailRowHeight;
    /**
     * @type {?}
     * @private
     */
    DataTableBodyComponent.prototype.cd;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wbnNiL0Rlc2t0b3AvTU9BIC0gRS1LQU5NQVMvbm9kZV9tb2R1bGVzL0Bzd2ltbGFuZS9uZ3gtZGF0YXRhYmxlL2VzbTUvbGliL2NvbXBvbmVudHMvYm9keS9ib2R5LmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQXkvQk0sQUFVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkE2Q0EiLCJmaWxlIjoiYm9keS5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIEhvc3RCaW5kaW5nLCBDaGFuZ2VEZXRlY3RvclJlZiwgVmlld0NoaWxkLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2Nyb2xsZXJDb21wb25lbnQgfSBmcm9tICcuL3Njcm9sbGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWxlY3Rpb25UeXBlIH0gZnJvbSAnLi4vLi4vdHlwZXMvc2VsZWN0aW9uLnR5cGUnO1xuaW1wb3J0IHsgY29sdW1uc0J5UGluLCBjb2x1bW5Hcm91cFdpZHRocyB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbHVtbic7XG5pbXBvcnQgeyBSb3dIZWlnaHRDYWNoZSB9IGZyb20gJy4uLy4uL3V0aWxzL3Jvdy1oZWlnaHQtY2FjaGUnO1xuaW1wb3J0IHsgdHJhbnNsYXRlWFkgfSBmcm9tICcuLi8uLi91dGlscy90cmFuc2xhdGUnO1xudmFyIERhdGFUYWJsZUJvZHlDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBEYXRhVGFibGVCb2R5Q29tcG9uZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFUYWJsZUJvZHlDb21wb25lbnQoY2QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gW107XG4gICAgICAgIHRoaXMuc2Nyb2xsID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnBhZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRldGFpbFRvZ2dsZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yb3dDb250ZXh0bWVudSA9IG5ldyBFdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICB0aGlzLnRyZWVBY3Rpb24gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucm93SGVpZ2h0c0NhY2hlID0gbmV3IFJvd0hlaWdodENhY2hlKCk7XG4gICAgICAgIHRoaXMudGVtcCA9IFtdO1xuICAgICAgICB0aGlzLm9mZnNldFkgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5yb3dJbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJvd0V4cGFuc2lvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBkZXRhaWwgcm93LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXREZXRhaWxSb3dIZWlnaHQgPSAoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHJvd1xuICAgICAgICAgKiBAcGFyYW0gez89fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHJvdywgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMucm93RGV0YWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgcm93SGVpZ2h0ID0gX3RoaXMucm93RGV0YWlsLnJvd0hlaWdodDtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygcm93SGVpZ2h0ID09PSAnZnVuY3Rpb24nID8gcm93SGVpZ2h0KHJvdywgaW5kZXgpIDogKCgvKiogQHR5cGUgez99ICovIChyb3dIZWlnaHQpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkZWNsYXJlIGZuIGhlcmUgc28gd2UgY2FuIGdldCBhY2Nlc3MgdG8gdGhlIGB0aGlzYCBwcm9wZXJ0eVxuICAgICAgICB0aGlzLnJvd1RyYWNraW5nRm4gPSAoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHs/fSByb3dcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChpbmRleCwgcm93KSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgaWR4ID0gX3RoaXMuZ2V0Um93SW5kZXgocm93KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy50cmFja0J5UHJvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3dbX3RoaXMudHJhY2tCeVByb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWdlU2l6ZVwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFnZVNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWdlU2l6ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjTGF5b3V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3dzXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3dzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fcm93cyA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjTGF5b3V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2x1bW5zXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1ucyA9IHZhbDtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBjb2xzQnlQaW4gPSBjb2x1bW5zQnlQaW4odmFsKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uR3JvdXBXaWR0aHMgPSBjb2x1bW5Hcm91cFdpZHRocyhjb2xzQnlQaW4sIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvZmZzZXRcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IHZhbDtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxiYXJWIHx8ICh0aGlzLnNjcm9sbGJhclYgJiYgIXRoaXMudmlydHVhbGl6YXRpb24pKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjTGF5b3V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3dDb3VudFwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm93Q291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dDb3VudCA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjTGF5b3V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJib2R5V2lkdGhcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsYmFySCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlubmVyV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcxMDAlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcImJvZHlIZWlnaHRcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHlIZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxiYXJWKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUhlaWdodCA9IHZhbCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5SGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWNhbGNMYXlvdXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdEVuYWJsZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBpZiBzZWxlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIFJldHVybnMgaWYgc2VsZWN0aW9uIGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLnNlbGVjdGlvblR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxIZWlnaHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydHkgdGhhdCB3b3VsZCBjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiBzY3JvbGwgYmFyXG4gICAgICAgICAqIGJhc2VkIG9uIHRoZSByb3cgaGVpZ2h0cyBjYWNoZSBmb3IgdmlydHVhbCBzY3JvbGwgYW5kIHZpcnR1YWxpemF0aW9uLiBPdGhlciBzY2VuYXJpb3NcbiAgICAgICAgICogY2FsY3VsYXRlIHNjcm9sbCBoZWlnaHQgYXV0b21hdGljYWxseSAoYXMgaGVpZ2h0IHdpbGwgYmUgdW5kZWZpbmVkKS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIFByb3BlcnR5IHRoYXQgd291bGQgY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2Ygc2Nyb2xsIGJhclxuICAgICAgICAgKiBiYXNlZCBvbiB0aGUgcm93IGhlaWdodHMgY2FjaGUgZm9yIHZpcnR1YWwgc2Nyb2xsIGFuZCB2aXJ0dWFsaXphdGlvbi4gT3RoZXIgc2NlbmFyaW9zXG4gICAgICAgICAqIGNhbGN1bGF0ZSBzY3JvbGwgaGVpZ2h0IGF1dG9tYXRpY2FsbHkgKGFzIGhlaWdodCB3aWxsIGJlIHVuZGVmaW5lZCkuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxiYXJWICYmIHRoaXMudmlydHVhbGl6YXRpb24gJiYgdGhpcy5yb3dDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlaWdodHNDYWNoZS5xdWVyeSh0aGlzLnJvd0NvdW50IC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdm9pZCBUUzcwMzA6IE5vdCBhbGwgY29kZSBwYXRocyByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgY29uc3RydWN0b3IsIGluaXRpYWxpemluZyBpbnB1dCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIHRoZSBjb25zdHJ1Y3RvciwgaW5pdGlhbGl6aW5nIGlucHV0IHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLm5nT25Jbml0ID0gLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIHRoZSBjb25zdHJ1Y3RvciwgaW5pdGlhbGl6aW5nIGlucHV0IHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucm93RGV0YWlsKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyID0gdGhpcy5yb3dEZXRhaWwudG9nZ2xlLnN1YnNjcmliZSgoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAncm93Jykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2dnbGVSb3dFeHBhbnNpb24odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlQWxsUm93cyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlZnJlc2ggcm93cyBhZnRlciB0b2dnbGVcbiAgICAgICAgICAgICAgICAvLyBGaXhlcyAjODgzXG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlSW5kZXhlcygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVJvd3MoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncm91cEhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lciA9IHRoaXMuZ3JvdXBIZWFkZXIudG9nZ2xlLnN1YnNjcmliZSgoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZVJvd0V4cGFuc2lvbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2dnbGVBbGxSb3dzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVmcmVzaCByb3dzIGFmdGVyIHRvZ2dsZVxuICAgICAgICAgICAgICAgIC8vIEZpeGVzICM4ODNcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVJbmRleGVzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUm93cygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb25jZSwgYmVmb3JlIHRoZSBpbnN0YW5jZSBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uY2UsIGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgZGVzdHJveWVkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSAvKipcbiAgICAgKiBDYWxsZWQgb25jZSwgYmVmb3JlIHRoZSBpbnN0YW5jZSBpcyBkZXN0cm95ZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvd0RldGFpbCB8fCB0aGlzLmdyb3VwSGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIFkgb2Zmc2V0IGdpdmVuIGEgbmV3IG9mZnNldC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBZIG9mZnNldCBnaXZlbiBhIG5ldyBvZmZzZXQuXG4gICAgICogQHBhcmFtIHs/PX0gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVPZmZzZXRZID0gLyoqXG4gICAgICogVXBkYXRlcyB0aGUgWSBvZmZzZXQgZ2l2ZW4gYSBuZXcgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7Pz19IG9mZnNldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAvLyBzY3JvbGxlciBpcyBtaXNzaW5nIG9uIGVtcHR5IHRhYmxlXG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGJhclYgJiYgdGhpcy52aXJ0dWFsaXphdGlvbiAmJiBvZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGdldCB0aGUgcm93IEluZGV4IHRoYXQgd2UgbmVlZCB0byBtb3ZlIHRvLlxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHJvd0luZGV4ID0gdGhpcy5wYWdlU2l6ZSAqIG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMucm93SGVpZ2h0c0NhY2hlLnF1ZXJ5KHJvd0luZGV4IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY3JvbGxiYXJWICYmICF0aGlzLnZpcnR1YWxpemF0aW9uKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0T2Zmc2V0KG9mZnNldCB8fCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJvZHkgd2FzIHNjcm9sbGVkLCB0aGlzIGlzIG1haW5seSB1c2VmdWwgZm9yXG4gICAgICogd2hlbiBhIHVzZXIgaXMgc2VydmVyLXNpZGUgcGFnaW5hdGlvbiB2aWEgdmlydHVhbCBzY3JvbGwuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQm9keSB3YXMgc2Nyb2xsZWQsIHRoaXMgaXMgbWFpbmx5IHVzZWZ1bCBmb3JcbiAgICAgKiB3aGVuIGEgdXNlciBpcyBzZXJ2ZXItc2lkZSBwYWdpbmF0aW9uIHZpYSB2aXJ0dWFsIHNjcm9sbC5cbiAgICAgKiBAcGFyYW0gez99IGV2ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5vbkJvZHlTY3JvbGwgPSAvKipcbiAgICAgKiBCb2R5IHdhcyBzY3JvbGxlZCwgdGhpcyBpcyBtYWlubHkgdXNlZnVsIGZvclxuICAgICAqIHdoZW4gYSB1c2VyIGlzIHNlcnZlci1zaWRlIHBhZ2luYXRpb24gdmlhIHZpcnR1YWwgc2Nyb2xsLlxuICAgICAqIEBwYXJhbSB7P30gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBzY3JvbGxZUG9zID0gZXZlbnQuc2Nyb2xsWVBvcztcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgc2Nyb2xsWFBvcyA9IGV2ZW50LnNjcm9sbFhQb3M7XG4gICAgICAgIC8vIGlmIHNjcm9sbCBjaGFuZ2UsIHRyaWdnZXIgdXBkYXRlXG4gICAgICAgIC8vIHRoaXMgaXMgbWFpbmx5IHVzZWQgZm9yIGhlYWRlciBjZWxsIHBvc2l0aW9uc1xuICAgICAgICBpZiAodGhpcy5vZmZzZXRZICE9PSBzY3JvbGxZUG9zIHx8IHRoaXMub2Zmc2V0WCAhPT0gc2Nyb2xsWFBvcykge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGwuZW1pdCh7XG4gICAgICAgICAgICAgICAgb2Zmc2V0WTogc2Nyb2xsWVBvcyxcbiAgICAgICAgICAgICAgICBvZmZzZXRYOiBzY3JvbGxYUG9zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldFkgPSBzY3JvbGxZUG9zO1xuICAgICAgICB0aGlzLm9mZnNldFggPSBzY3JvbGxYUG9zO1xuICAgICAgICB0aGlzLnVwZGF0ZUluZGV4ZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVQYWdlKGV2ZW50LmRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMudXBkYXRlUm93cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcGFnZSBnaXZlbiBhIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBwYWdlIGdpdmVuIGEgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVQYWdlID0gLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcGFnZSBnaXZlbiBhIGRpcmVjdGlvbi5cbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmluZGV4ZXMuZmlyc3QgLyB0aGlzLnBhZ2VTaXplO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5mbG9vcihvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiAhaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlLmVtaXQoeyBvZmZzZXQ6IG9mZnNldCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcm93cyBpbiB0aGUgdmlldyBwb3J0XG4gICAgICovXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcm93cyBpbiB0aGUgdmlldyBwb3J0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVSb3dzID0gLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcm93cyBpbiB0aGUgdmlldyBwb3J0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuaW5kZXhlcywgZmlyc3QgPSBfYS5maXJzdCwgbGFzdCA9IF9hLmxhc3Q7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHJvd0luZGV4ID0gZmlyc3Q7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHRlbXAgPSBbXTtcbiAgICAgICAgdGhpcy5yb3dJbmRleGVzLmNsZWFyKCk7XG4gICAgICAgIC8vIGlmIGdyb3Vwcm93c2J5IGhhcyBiZWVuIHNwZWNpZmllZCB0cmVhdCByb3cgcGFnaW5nXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgYXMgZ3JvdXAgcGFnaW5nIHBhcmFtZXRlcnMgaWUgaWYgbGltaXQgMTAgaGFzIGJlZW5cbiAgICAgICAgLy8gc3BlY2lmaWVkIHRyZWF0IGl0IGFzIDEwIGdyb3VwcyByYXRoZXIgdGhhbiAxMCByb3dzXG4gICAgICAgIGlmICh0aGlzLmdyb3VwZWRSb3dzKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgbWF4Um93c1Blckdyb3VwID0gMztcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGdyb3VwIHNldCB0aGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHJvd3MgcGVyIGdyb3VwIHRoZSBzYW1lIGFzIHRoZSB0b3RhbCBudW1iZXIgb2Ygcm93c1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBlZFJvd3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbWF4Um93c1Blckdyb3VwID0gdGhpcy5ncm91cGVkUm93c1swXS52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocm93SW5kZXggPCBsYXN0ICYmIHJvd0luZGV4IDwgdGhpcy5ncm91cGVkUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGdyb3VwcyBpbnRvIHRoaXMgcGFnZVxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwZWRSb3dzW3Jvd0luZGV4XTtcbiAgICAgICAgICAgICAgICB0ZW1wW2lkeF0gPSBncm91cDtcbiAgICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgICAgICAvLyBHcm91cCBpbmRleCBpbiB0aGlzIGNvbnRleHRcbiAgICAgICAgICAgICAgICByb3dJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHJvd0luZGV4IDwgbGFzdCAmJiByb3dJbmRleCA8IHRoaXMucm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1tyb3dJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0luZGV4ZXMuc2V0KHJvdywgcm93SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wW2lkeF0gPSByb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgICAgIHJvd0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW1wID0gdGVtcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm93IGhlaWdodFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm93IGhlaWdodFxuICAgICAqIEBwYXJhbSB7P30gcm93XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5nZXRSb3dIZWlnaHQgPSAvKipcbiAgICAgKiBHZXQgdGhlIHJvdyBoZWlnaHRcbiAgICAgKiBAcGFyYW0gez99IHJvd1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAvLyBpZiBpdHMgYSBmdW5jdGlvbiByZXR1cm4gaXRcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJvd0hlaWdodCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVpZ2h0KHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgez99ICovICh0aGlzLnJvd0hlaWdodCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGdyb3VwIHRoZSBncm91cCB3aXRoIGFsbCByb3dzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBncm91cCB0aGUgZ3JvdXAgd2l0aCBhbGwgcm93c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBIZWlnaHQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGdyb3VwIHRoZSBncm91cCB3aXRoIGFsbCByb3dzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgcm93SGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3JvdXAudmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0ICs9IHRoaXMuZ2V0Um93QW5kRGV0YWlsSGVpZ2h0KGdyb3VwLnZhbHVlW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd0hlaWdodDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSByb3cgaGVpZ2h0IGJhc2VkIG9uIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgcm93LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSByb3cgaGVpZ2h0IGJhc2VkIG9uIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgcm93LlxuICAgICAqIEBwYXJhbSB7P30gcm93XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5nZXRSb3dBbmREZXRhaWxIZWlnaHQgPSAvKipcbiAgICAgKiBDYWxjdWxhdGUgcm93IGhlaWdodCBiYXNlZCBvbiB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgdGhlIHJvdy5cbiAgICAgKiBAcGFyYW0gez99IHJvd1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciByb3dIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodChyb3cpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBleHBhbmRlZCA9IHRoaXMuZ2V0Um93RXhwYW5kZWQocm93KTtcbiAgICAgICAgLy8gQWRkaW5nIGRldGFpbCByb3cgaGVpZ2h0IGlmIGl0cyBleHBhbmRlZC5cbiAgICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICByb3dIZWlnaHQgKz0gdGhpcy5nZXREZXRhaWxSb3dIZWlnaHQocm93KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93SGVpZ2h0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc3R5bGVzIGZvciB0aGUgcm93IHNvIHRoYXQgdGhlIHJvd3MgY2FuIGJlIG1vdmVkIGluIDJEIHNwYWNlXG4gICAgICogZHVyaW5nIHZpcnR1YWwgc2Nyb2xsIGluc2lkZSB0aGUgRE9NLiAgIEluIHRoZSBiZWxvdyBjYXNlIHRoZSBZIHBvc2l0aW9uIGlzXG4gICAgICogbWFuaXB1bGF0ZWQuICAgQXMgYW4gZXhhbXBsZSwgaWYgdGhlIGhlaWdodCBvZiByb3cgMCBpcyAzMCBweCBhbmQgcm93IDEgaXNcbiAgICAgKiAxMDAgcHggdGhlbiBmb2xsb3dpbmcgc3R5bGVzIGFyZSBnZW5lcmF0ZWQ6XG4gICAgICpcbiAgICAgKiB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpOyAgICAtPiAgcm93MFxuICAgICAqIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMHB4LCAzMHB4LCAwcHgpOyAgIC0+ICByb3cxXG4gICAgICogdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwcHgsIDEzMHB4LCAwcHgpOyAgLT4gIHJvdzJcbiAgICAgKlxuICAgICAqIFJvdyBoZWlnaHRzIGhhdmUgdG8gYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgcm93IGhlaWdodHMgY2FjaGUgYXMgd2Ugd29udFxuICAgICAqIGJlIGFibGUgdG8gZGV0ZXJtaW5lIHdoaWNoIHJvdyBpcyBvZiB3aGF0IGhlaWdodCBiZWZvcmUgaGFuZC4gIEluIHRoZSBhYm92ZVxuICAgICAqIGNhc2UgdGhlIHBvc2l0aW9uWSBvZiB0aGUgdHJhbnNsYXRlM2QgZm9yIHJvdzIgd291bGQgYmUgdGhlIHN1bSBvZiBhbGwgdGhlXG4gICAgICogaGVpZ2h0cyBvZiB0aGUgcm93cyBiZWZvcmUgaXQgKGkuZS4gcm93MCBhbmQgcm93MSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93cyB0aGUgcm93IHRoYXQgbmVlZHMgdG8gYmUgcGxhY2VkIGluIHRoZSAyRCBzcGFjZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgQ1NTMyBzdHlsZSB0byBiZSBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVRhYmxlQm9keUNvbXBvbmVudFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHN0eWxlcyBmb3IgdGhlIHJvdyBzbyB0aGF0IHRoZSByb3dzIGNhbiBiZSBtb3ZlZCBpbiAyRCBzcGFjZVxuICAgICAqIGR1cmluZyB2aXJ0dWFsIHNjcm9sbCBpbnNpZGUgdGhlIERPTS4gICBJbiB0aGUgYmVsb3cgY2FzZSB0aGUgWSBwb3NpdGlvbiBpc1xuICAgICAqIG1hbmlwdWxhdGVkLiAgIEFzIGFuIGV4YW1wbGUsIGlmIHRoZSBoZWlnaHQgb2Ygcm93IDAgaXMgMzAgcHggYW5kIHJvdyAxIGlzXG4gICAgICogMTAwIHB4IHRoZW4gZm9sbG93aW5nIHN0eWxlcyBhcmUgZ2VuZXJhdGVkOlxuICAgICAqXG4gICAgICogdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KTsgICAgLT4gIHJvdzBcbiAgICAgKiB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDBweCwgMzBweCwgMHB4KTsgICAtPiAgcm93MVxuICAgICAqIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMHB4LCAxMzBweCwgMHB4KTsgIC0+ICByb3cyXG4gICAgICpcbiAgICAgKiBSb3cgaGVpZ2h0cyBoYXZlIHRvIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIHJvdyBoZWlnaHRzIGNhY2hlIGFzIHdlIHdvbnRcbiAgICAgKiBiZSBhYmxlIHRvIGRldGVybWluZSB3aGljaCByb3cgaXMgb2Ygd2hhdCBoZWlnaHQgYmVmb3JlIGhhbmQuICBJbiB0aGUgYWJvdmVcbiAgICAgKiBjYXNlIHRoZSBwb3NpdGlvblkgb2YgdGhlIHRyYW5zbGF0ZTNkIGZvciByb3cyIHdvdWxkIGJlIHRoZSBzdW0gb2YgYWxsIHRoZVxuICAgICAqIGhlaWdodHMgb2YgdGhlIHJvd3MgYmVmb3JlIGl0IChpLmUuIHJvdzAgYW5kIHJvdzEpLlxuICAgICAqXG4gICAgICogXFxAbWVtYmVyT2YgRGF0YVRhYmxlQm9keUNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7P30gcm93cyB0aGUgcm93IHRoYXQgbmVlZHMgdG8gYmUgcGxhY2VkIGluIHRoZSAyRCBzcGFjZS5cbiAgICAgKiBAcmV0dXJuIHs/fSB0aGUgQ1NTMyBzdHlsZSB0byBiZSBhcHBsaWVkXG4gICAgICpcbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5nZXRSb3dzU3R5bGVzID0gLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc3R5bGVzIGZvciB0aGUgcm93IHNvIHRoYXQgdGhlIHJvd3MgY2FuIGJlIG1vdmVkIGluIDJEIHNwYWNlXG4gICAgICogZHVyaW5nIHZpcnR1YWwgc2Nyb2xsIGluc2lkZSB0aGUgRE9NLiAgIEluIHRoZSBiZWxvdyBjYXNlIHRoZSBZIHBvc2l0aW9uIGlzXG4gICAgICogbWFuaXB1bGF0ZWQuICAgQXMgYW4gZXhhbXBsZSwgaWYgdGhlIGhlaWdodCBvZiByb3cgMCBpcyAzMCBweCBhbmQgcm93IDEgaXNcbiAgICAgKiAxMDAgcHggdGhlbiBmb2xsb3dpbmcgc3R5bGVzIGFyZSBnZW5lcmF0ZWQ6XG4gICAgICpcbiAgICAgKiB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpOyAgICAtPiAgcm93MFxuICAgICAqIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMHB4LCAzMHB4LCAwcHgpOyAgIC0+ICByb3cxXG4gICAgICogdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwcHgsIDEzMHB4LCAwcHgpOyAgLT4gIHJvdzJcbiAgICAgKlxuICAgICAqIFJvdyBoZWlnaHRzIGhhdmUgdG8gYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgcm93IGhlaWdodHMgY2FjaGUgYXMgd2Ugd29udFxuICAgICAqIGJlIGFibGUgdG8gZGV0ZXJtaW5lIHdoaWNoIHJvdyBpcyBvZiB3aGF0IGhlaWdodCBiZWZvcmUgaGFuZC4gIEluIHRoZSBhYm92ZVxuICAgICAqIGNhc2UgdGhlIHBvc2l0aW9uWSBvZiB0aGUgdHJhbnNsYXRlM2QgZm9yIHJvdzIgd291bGQgYmUgdGhlIHN1bSBvZiBhbGwgdGhlXG4gICAgICogaGVpZ2h0cyBvZiB0aGUgcm93cyBiZWZvcmUgaXQgKGkuZS4gcm93MCBhbmQgcm93MSkuXG4gICAgICpcbiAgICAgKiBcXEBtZW1iZXJPZiBEYXRhVGFibGVCb2R5Q29tcG9uZW50XG4gICAgICogQHBhcmFtIHs/fSByb3dzIHRoZSByb3cgdGhhdCBuZWVkcyB0byBiZSBwbGFjZWQgaW4gdGhlIDJEIHNwYWNlLlxuICAgICAqIEByZXR1cm4gez99IHRoZSBDU1MzIHN0eWxlIHRvIGJlIGFwcGxpZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyb3dzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgICAgICAvLyBvbmx5IGFkZCBzdHlsZXMgZm9yIHRoZSBncm91cCBpZiB0aGVyZSBpcyBhIGdyb3VwXG4gICAgICAgIGlmICh0aGlzLmdyb3VwZWRSb3dzKSB7XG4gICAgICAgICAgICBzdHlsZXMud2lkdGggPSB0aGlzLmNvbHVtbkdyb3VwV2lkdGhzLnRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGJhclYgJiYgdGhpcy52aXJ0dWFsaXphdGlvbikge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5ncm91cGVkUm93cykge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbGF0ZXN0IHJvdyByb3dpbmRleCBpbiBhIGdyb3VwXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSByb3dzW3Jvd3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWR4ID0gcm93ID8gdGhpcy5nZXRSb3dJbmRleChyb3cpIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkeCA9IHRoaXMuZ2V0Um93SW5kZXgocm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zdCBwb3MgPSBpZHggKiByb3dIZWlnaHQ7XG4gICAgICAgICAgICAvLyBUaGUgcG9zaXRpb24gb2YgdGhpcyByb3cgd291bGQgYmUgdGhlIHN1bSBvZiBhbGwgcm93IGhlaWdodHNcbiAgICAgICAgICAgIC8vIHVudGlsIHRoZSBwcmV2aW91cyByb3cgcG9zaXRpb24uXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5yb3dIZWlnaHRzQ2FjaGUucXVlcnkoaWR4IC0gMSk7XG4gICAgICAgICAgICB0cmFuc2xhdGVYWShzdHlsZXMsIDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBib3R0b20gc3VtbWFyeSByb3cgb2Zmc2V0IGZvciBzY3JvbGxiYXIgbW9kZS5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjYWNoZSBhbmQgb2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICogc2VlIGRlc2NyaXB0aW9uIGZvciBgZ2V0Um93c1N0eWxlc2AgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgQ1NTMyBzdHlsZSB0byBiZSBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVRhYmxlQm9keUNvbXBvbmVudFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBib3R0b20gc3VtbWFyeSByb3cgb2Zmc2V0IGZvciBzY3JvbGxiYXIgbW9kZS5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjYWNoZSBhbmQgb2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICogc2VlIGRlc2NyaXB0aW9uIGZvciBgZ2V0Um93c1N0eWxlc2AgbWV0aG9kXG4gICAgICpcbiAgICAgKiBcXEBtZW1iZXJPZiBEYXRhVGFibGVCb2R5Q29tcG9uZW50XG4gICAgICogQHJldHVybiB7P30gdGhlIENTUzMgc3R5bGUgdG8gYmUgYXBwbGllZFxuICAgICAqXG4gICAgICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0Qm90dG9tU3VtbWFyeVJvd1N0eWxlcyA9IC8qKlxuICAgICAqIENhbGN1bGF0ZSBib3R0b20gc3VtbWFyeSByb3cgb2Zmc2V0IGZvciBzY3JvbGxiYXIgbW9kZS5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjYWNoZSBhbmQgb2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICogc2VlIGRlc2NyaXB0aW9uIGZvciBgZ2V0Um93c1N0eWxlc2AgbWV0aG9kXG4gICAgICpcbiAgICAgKiBcXEBtZW1iZXJPZiBEYXRhVGFibGVCb2R5Q29tcG9uZW50XG4gICAgICogQHJldHVybiB7P30gdGhlIENTUzMgc3R5bGUgdG8gYmUgYXBwbGllZFxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsYmFyViB8fCAhdGhpcy5yb3dzIHx8ICF0aGlzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBzdHlsZXMgPSB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnIH07XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucm93SGVpZ2h0c0NhY2hlLnF1ZXJ5KHRoaXMucm93cy5sZW5ndGggLSAxKTtcbiAgICAgICAgdHJhbnNsYXRlWFkoc3R5bGVzLCAwLCBwb3MpO1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICovXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5oaWRlSW5kaWNhdG9yID0gLyoqXG4gICAgICogSGlkZXMgdGhlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmxvYWRpbmdJbmRpY2F0b3IgPSBmYWxzZSk7IH0pLCA1MDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW5kZXggb2YgdGhlIHJvd3MgaW4gdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW5kZXggb2YgdGhlIHJvd3MgaW4gdGhlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVJbmRleGVzID0gLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW5kZXggb2YgdGhlIHJvd3MgaW4gdGhlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGZpcnN0ID0gMDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgbGFzdCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGJhclYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpcnR1YWxpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRpb24gb2YgdGhlIGZpcnN0IGFuZCBsYXN0IGluZGV4ZXMgd2lsbCBiZSBiYXNlZCBvbiB3aGVyZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGxZIHBvc2l0aW9uIHdvdWxkIGJlIGF0LiAgVGhlIGxhc3QgaW5kZXggd291bGQgYmUgdGhlIG9uZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgc2hvd3MgdXAgaW5zaWRlIHRoZSB2aWV3IHBvcnQgdGhlIGxhc3QuXG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUludCh0aGlzLmJvZHlIZWlnaHQsIDApO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gdGhpcy5yb3dIZWlnaHRzQ2FjaGUuZ2V0Um93SW5kZXgodGhpcy5vZmZzZXRZKTtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdGhpcy5yb3dIZWlnaHRzQ2FjaGUuZ2V0Um93SW5kZXgoaGVpZ2h0ICsgdGhpcy5vZmZzZXRZKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB2aXJ0dWFsIHJvd3MgYXJlIG5vdCBuZWVkZWRcbiAgICAgICAgICAgICAgICAvLyBXZSByZW5kZXIgYWxsIGluIG9uZSBnb1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gMDtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdGhpcy5yb3dDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBzZXJ2ZXIgaXMgaGFuZGxpbmcgcGFnaW5nIGFuZCB3aWxsIHBhc3MgYW4gYXJyYXkgdGhhdCBiZWdpbnMgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgYXQgYSBzcGVjaWZpZWQgb2Zmc2V0LiAgZmlyc3Qgc2hvdWxkIGFsd2F5cyBiZSAwIHdpdGggZXh0ZXJuYWwgcGFnaW5nLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmV4dGVybmFsUGFnaW5nKSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBNYXRoLm1heCh0aGlzLm9mZnNldCAqIHRoaXMucGFnZVNpemUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdCA9IE1hdGgubWluKGZpcnN0ICsgdGhpcy5wYWdlU2l6ZSwgdGhpcy5yb3dDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleGVzID0geyBmaXJzdDogZmlyc3QsIGxhc3Q6IGxhc3QgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgZnVsbCBSb3cgSGVpZ2h0IGNhY2hlLiAgU2hvdWxkIGJlIHVzZWRcbiAgICAgKiB3aGVuIHRoZSBlbnRpcmUgcm93IGFycmF5IHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgZnVsbCBSb3cgSGVpZ2h0IGNhY2hlLiAgU2hvdWxkIGJlIHVzZWRcbiAgICAgKiB3aGVuIHRoZSBlbnRpcmUgcm93IGFycmF5IHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUucmVmcmVzaFJvd0hlaWdodENhY2hlID0gLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBmdWxsIFJvdyBIZWlnaHQgY2FjaGUuICBTaG91bGQgYmUgdXNlZFxuICAgICAqIHdoZW4gdGhlIGVudGlyZSByb3cgYXJyYXkgc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsYmFyViB8fCAodGhpcy5zY3JvbGxiYXJWICYmICF0aGlzLnZpcnR1YWxpemF0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIHRoZSBwcmV2aW91cyByb3cgaGVpZ2h0IGNhY2hlIGlmIGFscmVhZHkgcHJlc2VudC5cbiAgICAgICAgLy8gdGhpcyBpcyB1c2VmdWwgZHVyaW5nIHNvcnRzLCBmaWx0ZXJzIHdoZXJlIHRoZSBzdGF0ZSBvZiB0aGVcbiAgICAgICAgLy8gcm93cyBhcnJheSBpcyBjaGFuZ2VkLlxuICAgICAgICB0aGlzLnJvd0hlaWdodHNDYWNoZS5jbGVhckNhY2hlKCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHRyZWUgb25seSBpZiB0aGVyZSBhcmUgcm93cyBpbnNpZGUgdGhlIHRyZWUuXG4gICAgICAgIGlmICh0aGlzLnJvd3MgJiYgdGhpcy5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIHJvd0V4cGFuc2lvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gdHNsaWJfMS5fX3ZhbHVlcyh0aGlzLnJvd3MpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Um93RXhwYW5kZWQocm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93RXhwYW5zaW9ucy5hZGQocm93KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm93SGVpZ2h0c0NhY2hlLmluaXRDYWNoZSh7XG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5yb3dzLFxuICAgICAgICAgICAgICAgIHJvd0hlaWdodDogdGhpcy5yb3dIZWlnaHQsXG4gICAgICAgICAgICAgICAgZGV0YWlsUm93SGVpZ2h0OiB0aGlzLmdldERldGFpbFJvd0hlaWdodCxcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZpcnR1YWw6IHRoaXMuc2Nyb2xsYmFyViAmJiB0aGlzLmV4dGVybmFsUGFnaW5nLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50OiB0aGlzLnJvd0NvdW50LFxuICAgICAgICAgICAgICAgIHJvd0luZGV4ZXM6IHRoaXMucm93SW5kZXhlcyxcbiAgICAgICAgICAgICAgICByb3dFeHBhbnNpb25zOiByb3dFeHBhbnNpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggZm9yIHRoZSB2aWV3IHBvcnRcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBmb3IgdGhlIHZpZXcgcG9ydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0QWRqdXN0ZWRWaWV3UG9ydEluZGV4ID0gLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggZm9yIHRoZSB2aWV3IHBvcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgcm93IGluZGV4IG9mIHRoZSBmaXJzdCByb3cgdGhhdCBpcyB2aXNpYmxlIG9uIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgLy8gSWYgdGhlIHNjcm9sbCBiYXIgaXMganVzdCBiZWxvdyB0aGUgcm93IHdoaWNoIGlzIGhpZ2hsaWdodGVkIHRoZW4gbWFrZSB0aGF0IGFzIHRoZVxuICAgICAgICAvLyBmaXJzdCBpbmRleC5cbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgdmlld1BvcnRGaXJzdFJvd0luZGV4ID0gdGhpcy5pbmRleGVzLmZpcnN0O1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxiYXJWICYmIHRoaXMudmlydHVhbGl6YXRpb24pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBvZmZzZXRTY3JvbGwgPSB0aGlzLnJvd0hlaWdodHNDYWNoZS5xdWVyeSh2aWV3UG9ydEZpcnN0Um93SW5kZXggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXRTY3JvbGwgPD0gdGhpcy5vZmZzZXRZID8gdmlld1BvcnRGaXJzdFJvd0luZGV4IC0gMSA6IHZpZXdQb3J0Rmlyc3RSb3dJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld1BvcnRGaXJzdFJvd0luZGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBFeHBhbnNpb24gb2YgdGhlIHJvdyBpLmUuIGlmIHRoZSByb3cgaXMgZXhwYW5kZWQgdGhlbiBpdCB3aWxsXG4gICAgICogY29sbGFwc2UgYW5kIHZpY2UgdmVyc2EuICAgTm90ZSB0aGF0IHRoZSBleHBhbmRlZCBzdGF0dXMgaXMgc3RvcmVkIGFzXG4gICAgICogYSBwYXJ0IG9mIHRoZSByb3cgb2JqZWN0IGl0c2VsZiBhcyB3ZSBoYXZlIHRvIHByZXNlcnZlIHRoZSBleHBhbmRlZCByb3dcbiAgICAgKiBzdGF0dXMgaW4gY2FzZSBvZiBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgb2YgdGhlIHJvdyBzZXQuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBFeHBhbnNpb24gb2YgdGhlIHJvdyBpLmUuIGlmIHRoZSByb3cgaXMgZXhwYW5kZWQgdGhlbiBpdCB3aWxsXG4gICAgICogY29sbGFwc2UgYW5kIHZpY2UgdmVyc2EuICAgTm90ZSB0aGF0IHRoZSBleHBhbmRlZCBzdGF0dXMgaXMgc3RvcmVkIGFzXG4gICAgICogYSBwYXJ0IG9mIHRoZSByb3cgb2JqZWN0IGl0c2VsZiBhcyB3ZSBoYXZlIHRvIHByZXNlcnZlIHRoZSBleHBhbmRlZCByb3dcbiAgICAgKiBzdGF0dXMgaW4gY2FzZSBvZiBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgb2YgdGhlIHJvdyBzZXQuXG4gICAgICogQHBhcmFtIHs/fSByb3dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnRvZ2dsZVJvd0V4cGFuc2lvbiA9IC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgRXhwYW5zaW9uIG9mIHRoZSByb3cgaS5lLiBpZiB0aGUgcm93IGlzIGV4cGFuZGVkIHRoZW4gaXQgd2lsbFxuICAgICAqIGNvbGxhcHNlIGFuZCB2aWNlIHZlcnNhLiAgIE5vdGUgdGhhdCB0aGUgZXhwYW5kZWQgc3RhdHVzIGlzIHN0b3JlZCBhc1xuICAgICAqIGEgcGFydCBvZiB0aGUgcm93IG9iamVjdCBpdHNlbGYgYXMgd2UgaGF2ZSB0byBwcmVzZXJ2ZSB0aGUgZXhwYW5kZWQgcm93XG4gICAgICogc3RhdHVzIGluIGNhc2Ugb2Ygc29ydGluZyBhbmQgZmlsdGVyaW5nIG9mIHRoZSByb3cgc2V0LlxuICAgICAqIEBwYXJhbSB7P30gcm93XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIC8vIENhcHR1cmUgdGhlIHJvdyBpbmRleCBvZiB0aGUgZmlyc3Qgcm93IHRoYXQgaXMgdmlzaWJsZSBvbiB0aGUgdmlld3BvcnQuXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHZpZXdQb3J0Rmlyc3RSb3dJbmRleCA9IHRoaXMuZ2V0QWRqdXN0ZWRWaWV3UG9ydEluZGV4KCk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHJvd0V4cGFuZGVkSWR4ID0gdGhpcy5nZXRSb3dFeHBhbmRlZElkeChyb3csIHRoaXMucm93RXhwYW5zaW9ucyk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGV4cGFuZGVkID0gcm93RXhwYW5kZWRJZHggPiAtMTtcbiAgICAgICAgLy8gSWYgdGhlIGRldGFpbFJvd0hlaWdodCBpcyBhdXRvIC0tPiBvbmx5IGluIGNhc2Ugb2Ygbm9uLXZpcnR1YWxpemVkIHNjcm9sbFxuICAgICAgICBpZiAodGhpcy5zY3JvbGxiYXJWICYmIHRoaXMudmlydHVhbGl6YXRpb24pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBkZXRhaWxSb3dIZWlnaHQgPSB0aGlzLmdldERldGFpbFJvd0hlaWdodChyb3cpICogKGV4cGFuZGVkID8gLTEgOiAxKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IGlkeCA9IHRoaXMucm93SW5kZXhlcy5nZXQocm93KSB8fCAwO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuZ2V0Um93SW5kZXgocm93KTtcbiAgICAgICAgICAgIHRoaXMucm93SGVpZ2h0c0NhY2hlLnVwZGF0ZShpZHgsIGRldGFpbFJvd0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB0b2dnbGVkIHJvdyBhbmQgdXBkYXRlIHRoaXZlIG5ldmVyZSBoZWlnaHRzIGluIHRoZSBjYWNoZS5cbiAgICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0V4cGFuc2lvbnMuc3BsaWNlKHJvd0V4cGFuZGVkSWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm93RXhwYW5zaW9ucy5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRhaWxUb2dnbGUuZW1pdCh7XG4gICAgICAgICAgICByb3dzOiBbcm93XSxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleDogdmlld1BvcnRGaXJzdFJvd0luZGV4XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhwYW5kL0NvbGxhcHNlIGFsbCB0aGUgcm93cyBubyBtYXR0ZXIgd2hhdCB0aGVpciBzdGF0ZSBpcy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBFeHBhbmQvQ29sbGFwc2UgYWxsIHRoZSByb3dzIG5vIG1hdHRlciB3aGF0IHRoZWlyIHN0YXRlIGlzLlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5kZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnRvZ2dsZUFsbFJvd3MgPSAvKipcbiAgICAgKiBFeHBhbmQvQ29sbGFwc2UgYWxsIHRoZSByb3dzIG5vIG1hdHRlciB3aGF0IHRoZWlyIHN0YXRlIGlzLlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5kZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChleHBhbmRlZCkge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgLy8gY2xlYXIgcHJldiBleHBhbnNpb25zXG4gICAgICAgIHRoaXMucm93RXhwYW5zaW9ucyA9IFtdO1xuICAgICAgICAvLyBDYXB0dXJlIHRoZSByb3cgaW5kZXggb2YgdGhlIGZpcnN0IHJvdyB0aGF0IGlzIHZpc2libGUgb24gdGhlIHZpZXdwb3J0LlxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB2aWV3UG9ydEZpcnN0Um93SW5kZXggPSB0aGlzLmdldEFkanVzdGVkVmlld1BvcnRJbmRleCgpO1xuICAgICAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSB0c2xpYl8xLl9fdmFsdWVzKHRoaXMucm93cyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0V4cGFuc2lvbnMucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY3JvbGxiYXJWKSB7XG4gICAgICAgICAgICAvLyBSZWZyZXNoIHRoZSBmdWxsIHJvdyBoZWlnaHRzIGNhY2hlIHNpbmNlIGV2ZXJ5IHJvdyB3YXMgYWZmZWN0ZWQuXG4gICAgICAgICAgICB0aGlzLnJlY2FsY0xheW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVtaXQgYWxsIHJvd3MgdGhhdCBoYXZlIGJlZW4gZXhwYW5kZWQuXG4gICAgICAgIHRoaXMuZGV0YWlsVG9nZ2xlLmVtaXQoe1xuICAgICAgICAgICAgcm93czogdGhpcy5yb3dzLFxuICAgICAgICAgICAgY3VycmVudEluZGV4OiB2aWV3UG9ydEZpcnN0Um93SW5kZXhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIHRhYmxlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIHRoZSB0YWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUucmVjYWxjTGF5b3V0ID0gLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIHRoZSB0YWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hSb3dIZWlnaHRDYWNoZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUluZGV4ZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVSb3dzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFja3MgdGhlIGNvbHVtblxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRyYWNrcyB0aGUgY29sdW1uXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7P30gY29sdW1uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5jb2x1bW5UcmFja2luZ0ZuID0gLyoqXG4gICAgICogVHJhY2tzIHRoZSBjb2x1bW5cbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/fSBjb2x1bW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChpbmRleCwgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW4uJCRpZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdyBwaW5uaW5nIGdyb3VwIHN0eWxlc1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdyBwaW5uaW5nIGdyb3VwIHN0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnN0eWxlc0J5R3JvdXAgPSAvKipcbiAgICAgKiBHZXRzIHRoZSByb3cgcGlubmluZyBncm91cCBzdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IGdyb3VwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgd2lkdGhzID0gdGhpcy5jb2x1bW5Hcm91cFdpZHRocztcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IHRoaXMub2Zmc2V0WDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoc1tncm91cF0gKyBcInB4XCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGdyb3VwID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVhZKHN0eWxlcywgb2Zmc2V0WCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3JvdXAgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBib2R5V2lkdGggPSBwYXJzZUludCh0aGlzLmlubmVyV2lkdGggKyAnJywgMCk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgdG90YWxEaWZmID0gd2lkdGhzLnRvdGFsIC0gYm9keVdpZHRoO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIG9mZnNldERpZmYgPSB0b3RhbERpZmYgLSBvZmZzZXRYO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldERpZmYgKiAtMTtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVhZKHN0eWxlcywgb2Zmc2V0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgcm93IHdhcyBleHBhbmRlZCBhbmQgc2V0IGRlZmF1bHQgcm93IGV4cGFuc2lvbiB3aGVuIHJvdyBleHBhbnNpb24gaXMgZW1wdHlcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSByb3cgd2FzIGV4cGFuZGVkIGFuZCBzZXQgZGVmYXVsdCByb3cgZXhwYW5zaW9uIHdoZW4gcm93IGV4cGFuc2lvbiBpcyBlbXB0eVxuICAgICAqIEBwYXJhbSB7P30gcm93XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5nZXRSb3dFeHBhbmRlZCA9IC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIHJvdyB3YXMgZXhwYW5kZWQgYW5kIHNldCBkZWZhdWx0IHJvdyBleHBhbnNpb24gd2hlbiByb3cgZXhwYW5zaW9uIGlzIGVtcHR5XG4gICAgICogQHBhcmFtIHs/fSByb3dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgIGlmICh0aGlzLnJvd0V4cGFuc2lvbnMubGVuZ3RoID09PSAwICYmIHRoaXMuZ3JvdXBFeHBhbnNpb25EZWZhdWx0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gdHNsaWJfMS5fX3ZhbHVlcyh0aGlzLmdyb3VwZWRSb3dzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dFeHBhbnNpb25zLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3dFeHBhbmRlZElkeChyb3csIHRoaXMucm93RXhwYW5zaW9ucykgPiAtMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm93XG4gICAgICogQHBhcmFtIHs/fSBleHBhbmRlZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0Um93RXhwYW5kZWRJZHggPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvd1xuICAgICAqIEBwYXJhbSB7P30gZXhwYW5kZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChyb3csIGV4cGFuZGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghZXhwYW5kZWQgfHwgIWV4cGFuZGVkLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgcm93SWQgPSB0aGlzLnJvd0lkZW50aXR5KHJvdyk7XG4gICAgICAgIHJldHVybiBleHBhbmRlZC5maW5kSW5kZXgoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgaWQgPSBfdGhpcy5yb3dJZGVudGl0eShyKTtcbiAgICAgICAgICAgIHJldHVybiBpZCA9PT0gcm93SWQ7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdyBpbmRleCBnaXZlbiBhIHJvd1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdyBpbmRleCBnaXZlbiBhIHJvd1xuICAgICAqIEBwYXJhbSB7P30gcm93XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5nZXRSb3dJbmRleCA9IC8qKlxuICAgICAqIEdldHMgdGhlIHJvdyBpbmRleCBnaXZlbiBhIHJvd1xuICAgICAqIEBwYXJhbSB7P30gcm93XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd0luZGV4ZXMuZ2V0KHJvdykgfHwgMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm93XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5vblRyZWVBY3Rpb24gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvd1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB0aGlzLnRyZWVBY3Rpb24uZW1pdCh7IHJvdzogcm93IH0pO1xuICAgIH07XG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdkYXRhdGFibGUtYm9keScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGF0YXRhYmxlLXNlbGVjdGlvblxcbiAgICAgICNzZWxlY3RvclxcbiAgICAgIFtzZWxlY3RlZF09XFxcInNlbGVjdGVkXFxcIlxcbiAgICAgIFtyb3dzXT1cXFwicm93c1xcXCJcXG4gICAgICBbc2VsZWN0Q2hlY2tdPVxcXCJzZWxlY3RDaGVja1xcXCJcXG4gICAgICBbc2VsZWN0RW5hYmxlZF09XFxcInNlbGVjdEVuYWJsZWRcXFwiXFxuICAgICAgW3NlbGVjdGlvblR5cGVdPVxcXCJzZWxlY3Rpb25UeXBlXFxcIlxcbiAgICAgIFtyb3dJZGVudGl0eV09XFxcInJvd0lkZW50aXR5XFxcIlxcbiAgICAgIChzZWxlY3QpPVxcXCJzZWxlY3QuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxkYXRhdGFibGUtcHJvZ3Jlc3MgKm5nSWY9XFxcImxvYWRpbmdJbmRpY2F0b3JcXFwiPiA8L2RhdGF0YWJsZS1wcm9ncmVzcz5cXG4gICAgICA8ZGF0YXRhYmxlLXNjcm9sbGVyXFxuICAgICAgICAqbmdJZj1cXFwicm93cz8ubGVuZ3RoXFxcIlxcbiAgICAgICAgW3Njcm9sbGJhclZdPVxcXCJzY3JvbGxiYXJWXFxcIlxcbiAgICAgICAgW3Njcm9sbGJhckhdPVxcXCJzY3JvbGxiYXJIXFxcIlxcbiAgICAgICAgW3Njcm9sbEhlaWdodF09XFxcInNjcm9sbEhlaWdodFxcXCJcXG4gICAgICAgIFtzY3JvbGxXaWR0aF09XFxcImNvbHVtbkdyb3VwV2lkdGhzPy50b3RhbFxcXCJcXG4gICAgICAgIChzY3JvbGwpPVxcXCJvbkJvZHlTY3JvbGwoJGV2ZW50KVxcXCJcXG4gICAgICA+XFxuICAgICAgICA8ZGF0YXRhYmxlLXN1bW1hcnktcm93XFxuICAgICAgICAgICpuZ0lmPVxcXCJzdW1tYXJ5Um93ICYmIHN1bW1hcnlQb3NpdGlvbiA9PT0gJ3RvcCdcXFwiXFxuICAgICAgICAgIFtyb3dIZWlnaHRdPVxcXCJzdW1tYXJ5SGVpZ2h0XFxcIlxcbiAgICAgICAgICBbb2Zmc2V0WF09XFxcIm9mZnNldFhcXFwiXFxuICAgICAgICAgIFtpbm5lcldpZHRoXT1cXFwiaW5uZXJXaWR0aFxcXCJcXG4gICAgICAgICAgW3Jvd3NdPVxcXCJyb3dzXFxcIlxcbiAgICAgICAgICBbY29sdW1uc109XFxcImNvbHVtbnNcXFwiXFxuICAgICAgICA+XFxuICAgICAgICA8L2RhdGF0YWJsZS1zdW1tYXJ5LXJvdz5cXG4gICAgICAgIDxkYXRhdGFibGUtcm93LXdyYXBwZXJcXG4gICAgICAgICAgW2dyb3VwZWRSb3dzXT1cXFwiZ3JvdXBlZFJvd3NcXFwiXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGdyb3VwIG9mIHRlbXA7IGxldCBpID0gaW5kZXg7IHRyYWNrQnk6IHJvd1RyYWNraW5nRm5cXFwiXFxuICAgICAgICAgIFtpbm5lcldpZHRoXT1cXFwiaW5uZXJXaWR0aFxcXCJcXG4gICAgICAgICAgW25nU3R5bGVdPVxcXCJnZXRSb3dzU3R5bGVzKGdyb3VwKVxcXCJcXG4gICAgICAgICAgW3Jvd0RldGFpbF09XFxcInJvd0RldGFpbFxcXCJcXG4gICAgICAgICAgW2dyb3VwSGVhZGVyXT1cXFwiZ3JvdXBIZWFkZXJcXFwiXFxuICAgICAgICAgIFtvZmZzZXRYXT1cXFwib2Zmc2V0WFxcXCJcXG4gICAgICAgICAgW2RldGFpbFJvd0hlaWdodF09XFxcImdldERldGFpbFJvd0hlaWdodChncm91cFtpXSwgaSlcXFwiXFxuICAgICAgICAgIFtyb3ddPVxcXCJncm91cFxcXCJcXG4gICAgICAgICAgW2V4cGFuZGVkXT1cXFwiZ2V0Um93RXhwYW5kZWQoZ3JvdXApXFxcIlxcbiAgICAgICAgICBbcm93SW5kZXhdPVxcXCJnZXRSb3dJbmRleChncm91cFtpXSlcXFwiXFxuICAgICAgICAgIChyb3dDb250ZXh0bWVudSk9XFxcInJvd0NvbnRleHRtZW51LmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPGRhdGF0YWJsZS1ib2R5LXJvd1xcbiAgICAgICAgICAgICpuZ0lmPVxcXCIhZ3JvdXBlZFJvd3M7IGVsc2UgZ3JvdXBlZFJvd3NUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICB0YWJpbmRleD1cXFwiLTFcXFwiXFxuICAgICAgICAgICAgW2lzU2VsZWN0ZWRdPVxcXCJzZWxlY3Rvci5nZXRSb3dTZWxlY3RlZChncm91cClcXFwiXFxuICAgICAgICAgICAgW2lubmVyV2lkdGhdPVxcXCJpbm5lcldpZHRoXFxcIlxcbiAgICAgICAgICAgIFtvZmZzZXRYXT1cXFwib2Zmc2V0WFxcXCJcXG4gICAgICAgICAgICBbY29sdW1uc109XFxcImNvbHVtbnNcXFwiXFxuICAgICAgICAgICAgW3Jvd0hlaWdodF09XFxcImdldFJvd0hlaWdodChncm91cClcXFwiXFxuICAgICAgICAgICAgW3Jvd109XFxcImdyb3VwXFxcIlxcbiAgICAgICAgICAgIFtyb3dJbmRleF09XFxcImdldFJvd0luZGV4KGdyb3VwKVxcXCJcXG4gICAgICAgICAgICBbZXhwYW5kZWRdPVxcXCJnZXRSb3dFeHBhbmRlZChncm91cClcXFwiXFxuICAgICAgICAgICAgW3Jvd0NsYXNzXT1cXFwicm93Q2xhc3NcXFwiXFxuICAgICAgICAgICAgW2Rpc3BsYXlDaGVja109XFxcImRpc3BsYXlDaGVja1xcXCJcXG4gICAgICAgICAgICBbdHJlZVN0YXR1c109XFxcImdyb3VwLnRyZWVTdGF0dXNcXFwiXFxuICAgICAgICAgICAgKHRyZWVBY3Rpb24pPVxcXCJvblRyZWVBY3Rpb24oZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcInNlbGVjdG9yLm9uQWN0aXZhdGUoJGV2ZW50LCBpbmRleGVzLmZpcnN0ICsgaSlcXFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgPC9kYXRhdGFibGUtYm9keS1yb3c+XFxuICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjZ3JvdXBlZFJvd3NUZW1wbGF0ZT5cXG4gICAgICAgICAgICA8ZGF0YXRhYmxlLWJvZHktcm93XFxuICAgICAgICAgICAgICAqbmdGb3I9XFxcImxldCByb3cgb2YgZ3JvdXAudmFsdWU7IGxldCBpID0gaW5kZXg7IHRyYWNrQnk6IHJvd1RyYWNraW5nRm5cXFwiXFxuICAgICAgICAgICAgICB0YWJpbmRleD1cXFwiLTFcXFwiXFxuICAgICAgICAgICAgICBbaXNTZWxlY3RlZF09XFxcInNlbGVjdG9yLmdldFJvd1NlbGVjdGVkKHJvdylcXFwiXFxuICAgICAgICAgICAgICBbaW5uZXJXaWR0aF09XFxcImlubmVyV2lkdGhcXFwiXFxuICAgICAgICAgICAgICBbb2Zmc2V0WF09XFxcIm9mZnNldFhcXFwiXFxuICAgICAgICAgICAgICBbY29sdW1uc109XFxcImNvbHVtbnNcXFwiXFxuICAgICAgICAgICAgICBbcm93SGVpZ2h0XT1cXFwiZ2V0Um93SGVpZ2h0KHJvdylcXFwiXFxuICAgICAgICAgICAgICBbcm93XT1cXFwicm93XFxcIlxcbiAgICAgICAgICAgICAgW2dyb3VwXT1cXFwiZ3JvdXAudmFsdWVcXFwiXFxuICAgICAgICAgICAgICBbcm93SW5kZXhdPVxcXCJnZXRSb3dJbmRleChyb3cpXFxcIlxcbiAgICAgICAgICAgICAgW2V4cGFuZGVkXT1cXFwiZ2V0Um93RXhwYW5kZWQocm93KVxcXCJcXG4gICAgICAgICAgICAgIFtyb3dDbGFzc109XFxcInJvd0NsYXNzXFxcIlxcbiAgICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwic2VsZWN0b3Iub25BY3RpdmF0ZSgkZXZlbnQsIGkpXFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICA8L2RhdGF0YWJsZS1ib2R5LXJvdz5cXG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgIDwvZGF0YXRhYmxlLXJvdy13cmFwcGVyPlxcbiAgICAgICAgPGRhdGF0YWJsZS1zdW1tYXJ5LXJvd1xcbiAgICAgICAgICAqbmdJZj1cXFwic3VtbWFyeVJvdyAmJiBzdW1tYXJ5UG9zaXRpb24gPT09ICdib3R0b20nXFxcIlxcbiAgICAgICAgICBbbmdTdHlsZV09XFxcImdldEJvdHRvbVN1bW1hcnlSb3dTdHlsZXMoKVxcXCJcXG4gICAgICAgICAgW3Jvd0hlaWdodF09XFxcInN1bW1hcnlIZWlnaHRcXFwiXFxuICAgICAgICAgIFtvZmZzZXRYXT1cXFwib2Zmc2V0WFxcXCJcXG4gICAgICAgICAgW2lubmVyV2lkdGhdPVxcXCJpbm5lcldpZHRoXFxcIlxcbiAgICAgICAgICBbcm93c109XFxcInJvd3NcXFwiXFxuICAgICAgICAgIFtjb2x1bW5zXT1cXFwiY29sdW1uc1xcXCJcXG4gICAgICAgID5cXG4gICAgICAgIDwvZGF0YXRhYmxlLXN1bW1hcnktcm93PlxcbiAgICAgIDwvZGF0YXRhYmxlLXNjcm9sbGVyPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImVtcHR5LXJvd1xcXCIgKm5nSWY9XFxcIiFyb3dzPy5sZW5ndGggJiYgIWxvYWRpbmdJbmRpY2F0b3JcXFwiIFtpbm5lckhUTUxdPVxcXCJlbXB0eU1lc3NhZ2VcXFwiPjwvZGl2PlxcbiAgICA8L2RhdGF0YWJsZS1zZWxlY3Rpb24+XFxuICBcIixcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZGF0YXRhYmxlLWJvZHknXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbiAgICBdOyB9O1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgIHNjcm9sbGJhclY6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBzY3JvbGxiYXJIOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgbG9hZGluZ0luZGljYXRvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGV4dGVybmFsUGFnaW5nOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgcm93SGVpZ2h0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgb2Zmc2V0WDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGVtcHR5TWVzc2FnZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHNlbGVjdGlvblR5cGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBzZWxlY3RlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHJvd0lkZW50aXR5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgcm93RGV0YWlsOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgZ3JvdXBIZWFkZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBzZWxlY3RDaGVjazogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGRpc3BsYXlDaGVjazogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHRyYWNrQnlQcm9wOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgcm93Q2xhc3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBncm91cGVkUm93czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGdyb3VwRXhwYW5zaW9uRGVmYXVsdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGlubmVyV2lkdGg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBncm91cFJvd3NCeTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHZpcnR1YWxpemF0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgc3VtbWFyeVJvdzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHN1bW1hcnlQb3NpdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHN1bW1hcnlIZWlnaHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBwYWdlU2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHJvd3M6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBjb2x1bW5zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgb2Zmc2V0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgcm93Q291bnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBib2R5V2lkdGg6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLndpZHRoJyxdIH1dLFxuICAgICAgICBib2R5SGVpZ2h0OiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLmhlaWdodCcsXSB9XSxcbiAgICAgICAgc2Nyb2xsOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIHBhZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICAgICAgYWN0aXZhdGU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICAgICAgc2VsZWN0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIGRldGFpbFRvZ2dsZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgICAgICByb3dDb250ZXh0bWVudTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgICAgICB0cmVlQWN0aW9uOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIHNjcm9sbGVyOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtTY3JvbGxlckNvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0sXSB9XVxuICAgIH07XG4gICAgcmV0dXJuIERhdGFUYWJsZUJvZHlDb21wb25lbnQ7XG59KCkpO1xuZXhwb3J0IHsgRGF0YVRhYmxlQm9keUNvbXBvbmVudCB9O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnNjcm9sbGJhclY7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnNjcm9sbGJhckg7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmxvYWRpbmdJbmRpY2F0b3I7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmV4dGVybmFsUGFnaW5nO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5yb3dIZWlnaHQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLm9mZnNldFg7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmVtcHR5TWVzc2FnZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuc2VsZWN0aW9uVHlwZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuc2VsZWN0ZWQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnJvd0lkZW50aXR5O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5yb3dEZXRhaWw7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmdyb3VwSGVhZGVyO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5zZWxlY3RDaGVjaztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuZGlzcGxheUNoZWNrO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5UHJvcDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUucm93Q2xhc3M7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmdyb3VwZWRSb3dzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5ncm91cEV4cGFuc2lvbkRlZmF1bHQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmlubmVyV2lkdGg7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmdyb3VwUm93c0J5O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS52aXJ0dWFsaXphdGlvbjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuc3VtbWFyeVJvdztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuc3VtbWFyeVBvc2l0aW9uO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5zdW1tYXJ5SGVpZ2h0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5zY3JvbGw7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnBhZ2U7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmFjdGl2YXRlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5zZWxlY3Q7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmRldGFpbFRvZ2dsZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUucm93Q29udGV4dG1lbnU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnRyZWVBY3Rpb247XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnNjcm9sbGVyO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5yb3dIZWlnaHRzQ2FjaGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnRlbXA7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLm9mZnNldFk7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmluZGV4ZXM7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmNvbHVtbkdyb3VwV2lkdGhzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5jb2x1bW5Hcm91cFdpZHRoc1dpdGhvdXRHcm91cDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUucm93VHJhY2tpbmdGbjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUubGlzdGVuZXI7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnJvd0luZGV4ZXM7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLnJvd0V4cGFuc2lvbnM7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLl9yb3dzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVCb2R5Q29tcG9uZW50LnByb3RvdHlwZS5fYm9keUhlaWdodDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuX2NvbHVtbnM7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLl9yb3dDb3VudDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuX29mZnNldDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5wcm90b3R5cGUuX3BhZ2VTaXplO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBkZXRhaWwgcm93LlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmdldERldGFpbFJvd0hlaWdodDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERhdGFUYWJsZUJvZHlDb21wb25lbnQucHJvdG90eXBlLmNkO1xufVxuIl19