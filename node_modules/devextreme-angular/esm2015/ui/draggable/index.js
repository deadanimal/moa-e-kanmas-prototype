/*!
 * devextreme-angular
 * Version: 19.2.6
 * Build date: Thu Jan 30 2020
 *
 * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-angular
 */
import * as tslib_1 from "tslib";
/* tslint:disable:max-line-length */
import { BrowserTransferStateModule } from '@angular/platform-browser';
import { TransferState } from '@angular/platform-browser';
import { Component, NgModule, ElementRef, NgZone, PLATFORM_ID, Inject, Input, Output, OnDestroy, EventEmitter } from '@angular/core';
import DxDraggable from 'devextreme/ui/draggable';
import { DxComponent, DxTemplateHost, DxIntegrationModule, DxTemplateModule, NestedOptionHost, WatcherHelper } from 'devextreme-angular/core';
import { DxoCursorOffsetModule } from 'devextreme-angular/ui/nested';
/**
 * Draggable is a user interface utility that allows widget elements to be dragged and dropped.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'devextreme-angular/core';
import * as ɵngcc2 from '@angular/platform-browser';

const _c0 = ["*"];
let DxDraggableComponent = class DxDraggableComponent extends DxComponent {
    constructor(elementRef, ngZone, templateHost, _watcherHelper, optionHost, transferState, platformId) {
        super(elementRef, ngZone, templateHost, _watcherHelper, transferState, platformId);
        this._createEventEmitters([
            { subscribe: 'disposing', emit: 'onDisposing' },
            { subscribe: 'dragEnd', emit: 'onDragEnd' },
            { subscribe: 'dragMove', emit: 'onDragMove' },
            { subscribe: 'dragStart', emit: 'onDragStart' },
            { subscribe: 'initialized', emit: 'onInitialized' },
            { subscribe: 'optionChanged', emit: 'onOptionChanged' },
            { emit: 'autoScrollChange' },
            { emit: 'boundaryChange' },
            { emit: 'cloneChange' },
            { emit: 'containerChange' },
            { emit: 'cursorOffsetChange' },
            { emit: 'dataChange' },
            { emit: 'dragDirectionChange' },
            { emit: 'dragTemplateChange' },
            { emit: 'elementAttrChange' },
            { emit: 'groupChange' },
            { emit: 'handleChange' },
            { emit: 'heightChange' },
            { emit: 'rtlEnabledChange' },
            { emit: 'scrollSensitivityChange' },
            { emit: 'scrollSpeedChange' },
            { emit: 'widthChange' }
        ]);
        optionHost.setHost(this);
    }
    /**
     * Enables automatic scrolling while dragging an item beyond the viewport.
     */
    get autoScroll() {
        return this._getOption('autoScroll');
    }
    set autoScroll(value) {
        this._setOption('autoScroll', value);
    }
    /**
     * Specifies a DOM element that limits the dragging area.
     */
    get boundary() {
        return this._getOption('boundary');
    }
    set boundary(value) {
        this._setOption('boundary', value);
    }
    /**
     * Allows a user to drag clones of items instead of actual items.
     */
    get clone() {
        return this._getOption('clone');
    }
    set clone(value) {
        this._setOption('clone', value);
    }
    /**
     * Specifies a custom container in which the draggable item should be rendered.
     */
    get container() {
        return this._getOption('container');
    }
    set container(value) {
        this._setOption('container', value);
    }
    /**
     * Specifies the cursor offset from the dragged item.
     */
    get cursorOffset() {
        return this._getOption('cursorOffset');
    }
    set cursorOffset(value) {
        this._setOption('cursorOffset', value);
    }
    /**
     * A container for custom data.
     */
    get data() {
        return this._getOption('data');
    }
    set data(value) {
        this._setOption('data', value);
    }
    /**
     * Specifies the directions in which an item can be dragged.
     */
    get dragDirection() {
        return this._getOption('dragDirection');
    }
    set dragDirection(value) {
        this._setOption('dragDirection', value);
    }
    /**
     * Specifies custom markup to be shown instead of the item being dragged.
     */
    get dragTemplate() {
        return this._getOption('dragTemplate');
    }
    set dragTemplate(value) {
        this._setOption('dragTemplate', value);
    }
    /**
     * Specifies the attributes to be attached to the widget's root element.
     */
    get elementAttr() {
        return this._getOption('elementAttr');
    }
    set elementAttr(value) {
        this._setOption('elementAttr', value);
    }
    /**
     * Allows you to group several widgets, so that users can drag and drop items between them.
     */
    get group() {
        return this._getOption('group');
    }
    set group(value) {
        this._setOption('group', value);
    }
    /**
     * Specifies a CSS selector (ID or class) that should act as the drag handle(s) for the item(s).
     */
    get handle() {
        return this._getOption('handle');
    }
    set handle(value) {
        this._setOption('handle', value);
    }
    /**
     * Specifies the widget's height.
     */
    get height() {
        return this._getOption('height');
    }
    set height(value) {
        this._setOption('height', value);
    }
    /**
     * Switches the widget to a right-to-left representation.
     */
    get rtlEnabled() {
        return this._getOption('rtlEnabled');
    }
    set rtlEnabled(value) {
        this._setOption('rtlEnabled', value);
    }
    /**
     * Specifies the distance in pixels from the edge of viewport at which scrolling should start. Applies only if autoScroll is true.
     */
    get scrollSensitivity() {
        return this._getOption('scrollSensitivity');
    }
    set scrollSensitivity(value) {
        this._setOption('scrollSensitivity', value);
    }
    /**
     * Specifies the scrolling speed when dragging an item beyond the viewport. Applies only if autoScroll is true.
     */
    get scrollSpeed() {
        return this._getOption('scrollSpeed');
    }
    set scrollSpeed(value) {
        this._setOption('scrollSpeed', value);
    }
    /**
     * Specifies the widget's width.
     */
    get width() {
        return this._getOption('width');
    }
    set width(value) {
        this._setOption('width', value);
    }
    _createInstance(element, options) {
        return new DxDraggable(element, options);
    }
    ngOnDestroy() {
        this._destroyWidget();
    }
};
DxDraggableComponent.ɵfac = function DxDraggableComponent_Factory(t) { return new (t || DxDraggableComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DxTemplateHost), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.WatcherHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NestedOptionHost), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.TransferState), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
DxDraggableComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DxDraggableComponent, selectors: [["dx-draggable"]], inputs: { autoScroll: "autoScroll", boundary: "boundary", clone: "clone", container: "container", cursorOffset: "cursorOffset", data: "data", dragDirection: "dragDirection", dragTemplate: "dragTemplate", elementAttr: "elementAttr", group: "group", handle: "handle", height: "height", rtlEnabled: "rtlEnabled", scrollSensitivity: "scrollSensitivity", scrollSpeed: "scrollSpeed", width: "width" }, outputs: { onDisposing: "onDisposing", onDragEnd: "onDragEnd", onDragMove: "onDragMove", onDragStart: "onDragStart", onInitialized: "onInitialized", onOptionChanged: "onOptionChanged", autoScrollChange: "autoScrollChange", boundaryChange: "boundaryChange", cloneChange: "cloneChange", containerChange: "containerChange", cursorOffsetChange: "cursorOffsetChange", dataChange: "dataChange", dragDirectionChange: "dragDirectionChange", dragTemplateChange: "dragTemplateChange", elementAttrChange: "elementAttrChange", groupChange: "groupChange", handleChange: "handleChange", heightChange: "heightChange", rtlEnabledChange: "rtlEnabledChange", scrollSensitivityChange: "scrollSensitivityChange", scrollSpeedChange: "scrollSpeedChange", widthChange: "widthChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            DxTemplateHost,
            WatcherHelper,
            NestedOptionHost
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function DxDraggableComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
DxDraggableComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: DxTemplateHost },
    { type: WatcherHelper },
    { type: NestedOptionHost },
    { type: TransferState },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], DxDraggableComponent.prototype, "autoScroll", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], DxDraggableComponent.prototype, "boundary", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], DxDraggableComponent.prototype, "clone", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], DxDraggableComponent.prototype, "container", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], DxDraggableComponent.prototype, "cursorOffset", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], DxDraggableComponent.prototype, "data", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], DxDraggableComponent.prototype, "dragDirection", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], DxDraggableComponent.prototype, "dragTemplate", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], DxDraggableComponent.prototype, "elementAttr", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], DxDraggableComponent.prototype, "group", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], DxDraggableComponent.prototype, "handle", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], DxDraggableComponent.prototype, "height", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], DxDraggableComponent.prototype, "rtlEnabled", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], DxDraggableComponent.prototype, "scrollSensitivity", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], DxDraggableComponent.prototype, "scrollSpeed", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], DxDraggableComponent.prototype, "width", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "onDisposing", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "onDragEnd", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "onDragMove", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "onDragStart", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "onInitialized", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "onOptionChanged", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "autoScrollChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "boundaryChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "cloneChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "containerChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "cursorOffsetChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "dataChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "dragDirectionChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "dragTemplateChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "elementAttrChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "groupChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "handleChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "heightChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "rtlEnabledChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "scrollSensitivityChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "scrollSpeedChange", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], DxDraggableComponent.prototype, "widthChange", void 0);
DxDraggableComponent = tslib_1.__decorate([ tslib_1.__param(6, Inject(PLATFORM_ID)),
    tslib_1.__metadata("design:paramtypes", [ElementRef, NgZone, DxTemplateHost,
        WatcherHelper,
        NestedOptionHost,
        TransferState, Object])
], DxDraggableComponent);
export { DxDraggableComponent };
let DxDraggableModule = class DxDraggableModule {
};
DxDraggableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DxDraggableModule });
DxDraggableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DxDraggableModule_Factory(t) { return new (t || DxDraggableModule)(); }, imports: [[
            DxoCursorOffsetModule,
            DxIntegrationModule,
            DxTemplateModule,
            BrowserTransferStateModule
        ],
        DxoCursorOffsetModule,
        DxTemplateModule] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DxDraggableComponent, [{
        type: Component,
        args: [{
                selector: 'dx-draggable',
                template: '<ng-content></ng-content>',
                providers: [
                    DxTemplateHost,
                    WatcherHelper,
                    NestedOptionHost
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.DxTemplateHost }, { type: ɵngcc1.WatcherHelper }, { type: ɵngcc1.NestedOptionHost }, { type: ɵngcc2.TransferState }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { autoScroll: [{
            type: Input
        }], boundary: [{
            type: Input
        }], clone: [{
            type: Input
        }], container: [{
            type: Input
        }], cursorOffset: [{
            type: Input
        }], data: [{
            type: Input
        }], dragDirection: [{
            type: Input
        }], dragTemplate: [{
            type: Input
        }], elementAttr: [{
            type: Input
        }], group: [{
            type: Input
        }], handle: [{
            type: Input
        }], height: [{
            type: Input
        }], rtlEnabled: [{
            type: Input
        }], scrollSensitivity: [{
            type: Input
        }], scrollSpeed: [{
            type: Input
        }], width: [{
            type: Input
        }], onDisposing: [{
            type: Output
        }], onDragEnd: [{
            type: Output
        }], onDragMove: [{
            type: Output
        }], onDragStart: [{
            type: Output
        }], onInitialized: [{
            type: Output
        }], onOptionChanged: [{
            type: Output
        }], autoScrollChange: [{
            type: Output
        }], boundaryChange: [{
            type: Output
        }], cloneChange: [{
            type: Output
        }], containerChange: [{
            type: Output
        }], cursorOffsetChange: [{
            type: Output
        }], dataChange: [{
            type: Output
        }], dragDirectionChange: [{
            type: Output
        }], dragTemplateChange: [{
            type: Output
        }], elementAttrChange: [{
            type: Output
        }], groupChange: [{
            type: Output
        }], handleChange: [{
            type: Output
        }], heightChange: [{
            type: Output
        }], rtlEnabledChange: [{
            type: Output
        }], scrollSensitivityChange: [{
            type: Output
        }], scrollSpeedChange: [{
            type: Output
        }], widthChange: [{
            type: Output
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DxDraggableModule, { declarations: function () { return [DxDraggableComponent]; }, imports: function () { return [DxoCursorOffsetModule,
        DxIntegrationModule,
        DxTemplateModule,
        BrowserTransferStateModule]; }, exports: function () { return [DxDraggableComponent,
        DxoCursorOffsetModule,
        DxTemplateModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DxDraggableModule, [{
        type: NgModule,
        args: [{
                imports: [
                    DxoCursorOffsetModule,
                    DxIntegrationModule,
                    DxTemplateModule,
                    BrowserTransferStateModule
                ],
                declarations: [
                    DxDraggableComponent
                ],
                exports: [
                    DxDraggableComponent,
                    DxoCursorOffsetModule,
                    DxTemplateModule
                ]
            }]
    }], null, null); })();
export { DxDraggableModule };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wbnNiL0Rlc2t0b3AvTU9BIC0gRS1LQU5NQVMvbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUtYW5ndWxhci9lc20yMDE1L3VpL2RyYWdnYWJsZS9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBbUxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJDQWtMeUMsQUFVeEM7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBUUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWtCb0IiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogZGV2ZXh0cmVtZS1hbmd1bGFyXHJcbiAqIFZlcnNpb246IDE5LjIuNlxyXG4gKiBCdWlsZCBkYXRlOiBUaHUgSmFuIDMwIDIwMjBcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMCBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICpcclxuICogVGhpcyBzb2Z0d2FyZSBtYXkgYmUgbW9kaWZpZWQgYW5kIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtc1xyXG4gKiBvZiB0aGUgTUlUIGxpY2Vuc2UuIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBwcm9qZWN0IGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRGV2RXhwcmVzcy9kZXZleHRyZW1lLWFuZ3VsYXJcclxuICovXHJcbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XHJcbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xyXG5pbXBvcnQgeyBCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBUcmFuc2ZlclN0YXRlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XHJcbmltcG9ydCB7IENvbXBvbmVudCwgTmdNb2R1bGUsIEVsZW1lbnRSZWYsIE5nWm9uZSwgUExBVEZPUk1fSUQsIEluamVjdCwgSW5wdXQsIE91dHB1dCwgT25EZXN0cm95LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IER4RHJhZ2dhYmxlIGZyb20gJ2RldmV4dHJlbWUvdWkvZHJhZ2dhYmxlJztcclxuaW1wb3J0IHsgRHhDb21wb25lbnQsIER4VGVtcGxhdGVIb3N0LCBEeEludGVncmF0aW9uTW9kdWxlLCBEeFRlbXBsYXRlTW9kdWxlLCBOZXN0ZWRPcHRpb25Ib3N0LCBXYXRjaGVySGVscGVyIH0gZnJvbSAnZGV2ZXh0cmVtZS1hbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBEeG9DdXJzb3JPZmZzZXRNb2R1bGUgfSBmcm9tICdkZXZleHRyZW1lLWFuZ3VsYXIvdWkvbmVzdGVkJztcclxuLyoqXHJcbiAqIERyYWdnYWJsZSBpcyBhIHVzZXIgaW50ZXJmYWNlIHV0aWxpdHkgdGhhdCBhbGxvd3Mgd2lkZ2V0IGVsZW1lbnRzIHRvIGJlIGRyYWdnZWQgYW5kIGRyb3BwZWQuXHJcbiAqL1xyXG5sZXQgRHhEcmFnZ2FibGVDb21wb25lbnQgPSBjbGFzcyBEeERyYWdnYWJsZUNvbXBvbmVudCBleHRlbmRzIER4Q29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWYsIG5nWm9uZSwgdGVtcGxhdGVIb3N0LCBfd2F0Y2hlckhlbHBlciwgb3B0aW9uSG9zdCwgdHJhbnNmZXJTdGF0ZSwgcGxhdGZvcm1JZCkge1xyXG4gICAgICAgIHN1cGVyKGVsZW1lbnRSZWYsIG5nWm9uZSwgdGVtcGxhdGVIb3N0LCBfd2F0Y2hlckhlbHBlciwgdHJhbnNmZXJTdGF0ZSwgcGxhdGZvcm1JZCk7XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlRXZlbnRFbWl0dGVycyhbXHJcbiAgICAgICAgICAgIHsgc3Vic2NyaWJlOiAnZGlzcG9zaW5nJywgZW1pdDogJ29uRGlzcG9zaW5nJyB9LFxyXG4gICAgICAgICAgICB7IHN1YnNjcmliZTogJ2RyYWdFbmQnLCBlbWl0OiAnb25EcmFnRW5kJyB9LFxyXG4gICAgICAgICAgICB7IHN1YnNjcmliZTogJ2RyYWdNb3ZlJywgZW1pdDogJ29uRHJhZ01vdmUnIH0sXHJcbiAgICAgICAgICAgIHsgc3Vic2NyaWJlOiAnZHJhZ1N0YXJ0JywgZW1pdDogJ29uRHJhZ1N0YXJ0JyB9LFxyXG4gICAgICAgICAgICB7IHN1YnNjcmliZTogJ2luaXRpYWxpemVkJywgZW1pdDogJ29uSW5pdGlhbGl6ZWQnIH0sXHJcbiAgICAgICAgICAgIHsgc3Vic2NyaWJlOiAnb3B0aW9uQ2hhbmdlZCcsIGVtaXQ6ICdvbk9wdGlvbkNoYW5nZWQnIH0sXHJcbiAgICAgICAgICAgIHsgZW1pdDogJ2F1dG9TY3JvbGxDaGFuZ2UnIH0sXHJcbiAgICAgICAgICAgIHsgZW1pdDogJ2JvdW5kYXJ5Q2hhbmdlJyB9LFxyXG4gICAgICAgICAgICB7IGVtaXQ6ICdjbG9uZUNoYW5nZScgfSxcclxuICAgICAgICAgICAgeyBlbWl0OiAnY29udGFpbmVyQ2hhbmdlJyB9LFxyXG4gICAgICAgICAgICB7IGVtaXQ6ICdjdXJzb3JPZmZzZXRDaGFuZ2UnIH0sXHJcbiAgICAgICAgICAgIHsgZW1pdDogJ2RhdGFDaGFuZ2UnIH0sXHJcbiAgICAgICAgICAgIHsgZW1pdDogJ2RyYWdEaXJlY3Rpb25DaGFuZ2UnIH0sXHJcbiAgICAgICAgICAgIHsgZW1pdDogJ2RyYWdUZW1wbGF0ZUNoYW5nZScgfSxcclxuICAgICAgICAgICAgeyBlbWl0OiAnZWxlbWVudEF0dHJDaGFuZ2UnIH0sXHJcbiAgICAgICAgICAgIHsgZW1pdDogJ2dyb3VwQ2hhbmdlJyB9LFxyXG4gICAgICAgICAgICB7IGVtaXQ6ICdoYW5kbGVDaGFuZ2UnIH0sXHJcbiAgICAgICAgICAgIHsgZW1pdDogJ2hlaWdodENoYW5nZScgfSxcclxuICAgICAgICAgICAgeyBlbWl0OiAncnRsRW5hYmxlZENoYW5nZScgfSxcclxuICAgICAgICAgICAgeyBlbWl0OiAnc2Nyb2xsU2Vuc2l0aXZpdHlDaGFuZ2UnIH0sXHJcbiAgICAgICAgICAgIHsgZW1pdDogJ3Njcm9sbFNwZWVkQ2hhbmdlJyB9LFxyXG4gICAgICAgICAgICB7IGVtaXQ6ICd3aWR0aENoYW5nZScgfVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIG9wdGlvbkhvc3Quc2V0SG9zdCh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyBhdXRvbWF0aWMgc2Nyb2xsaW5nIHdoaWxlIGRyYWdnaW5nIGFuIGl0ZW0gYmV5b25kIHRoZSB2aWV3cG9ydC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGF1dG9TY3JvbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wdGlvbignYXV0b1Njcm9sbCcpO1xyXG4gICAgfVxyXG4gICAgc2V0IGF1dG9TY3JvbGwodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zZXRPcHRpb24oJ2F1dG9TY3JvbGwnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyBhIERPTSBlbGVtZW50IHRoYXQgbGltaXRzIHRoZSBkcmFnZ2luZyBhcmVhLlxyXG4gICAgICovXHJcbiAgICBnZXQgYm91bmRhcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wdGlvbignYm91bmRhcnknKTtcclxuICAgIH1cclxuICAgIHNldCBib3VuZGFyeSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldE9wdGlvbignYm91bmRhcnknLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG93cyBhIHVzZXIgdG8gZHJhZyBjbG9uZXMgb2YgaXRlbXMgaW5zdGVhZCBvZiBhY3R1YWwgaXRlbXMuXHJcbiAgICAgKi9cclxuICAgIGdldCBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3B0aW9uKCdjbG9uZScpO1xyXG4gICAgfVxyXG4gICAgc2V0IGNsb25lKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9uKCdjbG9uZScsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIGEgY3VzdG9tIGNvbnRhaW5lciBpbiB3aGljaCB0aGUgZHJhZ2dhYmxlIGl0ZW0gc2hvdWxkIGJlIHJlbmRlcmVkLlxyXG4gICAgICovXHJcbiAgICBnZXQgY29udGFpbmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPcHRpb24oJ2NvbnRhaW5lcicpO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbnRhaW5lcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldE9wdGlvbignY29udGFpbmVyJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGN1cnNvciBvZmZzZXQgZnJvbSB0aGUgZHJhZ2dlZCBpdGVtLlxyXG4gICAgICovXHJcbiAgICBnZXQgY3Vyc29yT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPcHRpb24oJ2N1cnNvck9mZnNldCcpO1xyXG4gICAgfVxyXG4gICAgc2V0IGN1cnNvck9mZnNldCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldE9wdGlvbignY3Vyc29yT2Zmc2V0JywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbnRhaW5lciBmb3IgY3VzdG9tIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldCBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPcHRpb24oJ2RhdGEnKTtcclxuICAgIH1cclxuICAgIHNldCBkYXRhKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9uKCdkYXRhJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGRpcmVjdGlvbnMgaW4gd2hpY2ggYW4gaXRlbSBjYW4gYmUgZHJhZ2dlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyYWdEaXJlY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wdGlvbignZHJhZ0RpcmVjdGlvbicpO1xyXG4gICAgfVxyXG4gICAgc2V0IGRyYWdEaXJlY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zZXRPcHRpb24oJ2RyYWdEaXJlY3Rpb24nLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyBjdXN0b20gbWFya3VwIHRvIGJlIHNob3duIGluc3RlYWQgb2YgdGhlIGl0ZW0gYmVpbmcgZHJhZ2dlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyYWdUZW1wbGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3B0aW9uKCdkcmFnVGVtcGxhdGUnKTtcclxuICAgIH1cclxuICAgIHNldCBkcmFnVGVtcGxhdGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zZXRPcHRpb24oJ2RyYWdUZW1wbGF0ZScsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHRoZSBhdHRyaWJ1dGVzIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSB3aWRnZXQncyByb290IGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGdldCBlbGVtZW50QXR0cigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3B0aW9uKCdlbGVtZW50QXR0cicpO1xyXG4gICAgfVxyXG4gICAgc2V0IGVsZW1lbnRBdHRyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9uKCdlbGVtZW50QXR0cicsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIHlvdSB0byBncm91cCBzZXZlcmFsIHdpZGdldHMsIHNvIHRoYXQgdXNlcnMgY2FuIGRyYWcgYW5kIGRyb3AgaXRlbXMgYmV0d2VlbiB0aGVtLlxyXG4gICAgICovXHJcbiAgICBnZXQgZ3JvdXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wdGlvbignZ3JvdXAnKTtcclxuICAgIH1cclxuICAgIHNldCBncm91cCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldE9wdGlvbignZ3JvdXAnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyBhIENTUyBzZWxlY3RvciAoSUQgb3IgY2xhc3MpIHRoYXQgc2hvdWxkIGFjdCBhcyB0aGUgZHJhZyBoYW5kbGUocykgZm9yIHRoZSBpdGVtKHMpLlxyXG4gICAgICovXHJcbiAgICBnZXQgaGFuZGxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPcHRpb24oJ2hhbmRsZScpO1xyXG4gICAgfVxyXG4gICAgc2V0IGhhbmRsZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldE9wdGlvbignaGFuZGxlJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHdpZGdldCdzIGhlaWdodC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3B0aW9uKCdoZWlnaHQnKTtcclxuICAgIH1cclxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zZXRPcHRpb24oJ2hlaWdodCcsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3dpdGNoZXMgdGhlIHdpZGdldCB0byBhIHJpZ2h0LXRvLWxlZnQgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldCBydGxFbmFibGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPcHRpb24oJ3J0bEVuYWJsZWQnKTtcclxuICAgIH1cclxuICAgIHNldCBydGxFbmFibGVkKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9uKCdydGxFbmFibGVkJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGRpc3RhbmNlIGluIHBpeGVscyBmcm9tIHRoZSBlZGdlIG9mIHZpZXdwb3J0IGF0IHdoaWNoIHNjcm9sbGluZyBzaG91bGQgc3RhcnQuIEFwcGxpZXMgb25seSBpZiBhdXRvU2Nyb2xsIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBzY3JvbGxTZW5zaXRpdml0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3B0aW9uKCdzY3JvbGxTZW5zaXRpdml0eScpO1xyXG4gICAgfVxyXG4gICAgc2V0IHNjcm9sbFNlbnNpdGl2aXR5KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9uKCdzY3JvbGxTZW5zaXRpdml0eScsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHRoZSBzY3JvbGxpbmcgc3BlZWQgd2hlbiBkcmFnZ2luZyBhbiBpdGVtIGJleW9uZCB0aGUgdmlld3BvcnQuIEFwcGxpZXMgb25seSBpZiBhdXRvU2Nyb2xsIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBzY3JvbGxTcGVlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3B0aW9uKCdzY3JvbGxTcGVlZCcpO1xyXG4gICAgfVxyXG4gICAgc2V0IHNjcm9sbFNwZWVkKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9uKCdzY3JvbGxTcGVlZCcsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHRoZSB3aWRnZXQncyB3aWR0aC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPcHRpb24oJ3dpZHRoJyk7XHJcbiAgICB9XHJcbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zZXRPcHRpb24oJ3dpZHRoJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IER4RHJhZ2dhYmxlKGVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveVdpZGdldCgpO1xyXG4gICAgfVxyXG59O1xyXG5EeERyYWdnYWJsZUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcclxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxyXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcclxuICAgIHsgdHlwZTogRHhUZW1wbGF0ZUhvc3QgfSxcclxuICAgIHsgdHlwZTogV2F0Y2hlckhlbHBlciB9LFxyXG4gICAgeyB0eXBlOiBOZXN0ZWRPcHRpb25Ib3N0IH0sXHJcbiAgICB7IHR5cGU6IFRyYW5zZmVyU3RhdGUgfSxcclxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtQTEFURk9STV9JRCxdIH1dIH1cclxuXTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIElucHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9TY3JvbGxcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm91bmRhcnlcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbG9uZVwiLCBudWxsKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIElucHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250YWluZXJcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3Vyc29yT2Zmc2V0XCIsIG51bGwpO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgSW5wdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZHJhZ0RpcmVjdGlvblwiLCBudWxsKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIElucHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkcmFnVGVtcGxhdGVcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZWxlbWVudEF0dHJcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGFuZGxlXCIsIG51bGwpO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgSW5wdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCBudWxsKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIElucHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcInJ0bEVuYWJsZWRcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2Nyb2xsU2Vuc2l0aXZpdHlcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2Nyb2xsU3BlZWRcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBJbnB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgbnVsbCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRGlzcG9zaW5nXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRHJhZ0VuZFwiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgT3V0cHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkRyYWdNb3ZlXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRHJhZ1N0YXJ0XCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcIm9uSW5pdGlhbGl6ZWRcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25PcHRpb25DaGFuZ2VkXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9TY3JvbGxDaGFuZ2VcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm91bmRhcnlDaGFuZ2VcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvbmVDaGFuZ2VcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGFpbmVyQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnNvck9mZnNldENoYW5nZVwiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgT3V0cHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcImRyYWdEaXJlY3Rpb25DaGFuZ2VcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZHJhZ1RlbXBsYXRlQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcImVsZW1lbnRBdHRyQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3VwQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbnRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBPdXRwdXQoKSxcclxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuXSwgRHhEcmFnZ2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcImhhbmRsZUNoYW5nZVwiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgT3V0cHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRDaGFuZ2VcIiwgdm9pZCAwKTtcclxudHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgIE91dHB1dCgpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG5dLCBEeERyYWdnYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicnRsRW5hYmxlZENoYW5nZVwiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgT3V0cHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxTZW5zaXRpdml0eUNoYW5nZVwiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgT3V0cHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY3JvbGxTcGVlZENoYW5nZVwiLCB2b2lkIDApO1xyXG50c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgT3V0cHV0KCksXHJcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aENoYW5nZVwiLCB2b2lkIDApO1xyXG5EeERyYWdnYWJsZUNvbXBvbmVudCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBDb21wb25lbnQoe1xyXG4gICAgICAgIHNlbGVjdG9yOiAnZHgtZHJhZ2dhYmxlJyxcclxuICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgICAgICBEeFRlbXBsYXRlSG9zdCxcclxuICAgICAgICAgICAgV2F0Y2hlckhlbHBlcixcclxuICAgICAgICAgICAgTmVzdGVkT3B0aW9uSG9zdFxyXG4gICAgICAgIF1cclxuICAgIH0pLFxyXG4gICAgdHNsaWJfMS5fX3BhcmFtKDYsIEluamVjdChQTEFURk9STV9JRCkpLFxyXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgRHhUZW1wbGF0ZUhvc3QsXHJcbiAgICAgICAgV2F0Y2hlckhlbHBlcixcclxuICAgICAgICBOZXN0ZWRPcHRpb25Ib3N0LFxyXG4gICAgICAgIFRyYW5zZmVyU3RhdGUsIE9iamVjdF0pXHJcbl0sIER4RHJhZ2dhYmxlQ29tcG9uZW50KTtcclxuZXhwb3J0IHsgRHhEcmFnZ2FibGVDb21wb25lbnQgfTtcclxubGV0IER4RHJhZ2dhYmxlTW9kdWxlID0gY2xhc3MgRHhEcmFnZ2FibGVNb2R1bGUge1xyXG59O1xyXG5EeERyYWdnYWJsZU1vZHVsZSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgaW1wb3J0czogW1xyXG4gICAgICAgICAgICBEeG9DdXJzb3JPZmZzZXRNb2R1bGUsXHJcbiAgICAgICAgICAgIER4SW50ZWdyYXRpb25Nb2R1bGUsXHJcbiAgICAgICAgICAgIER4VGVtcGxhdGVNb2R1bGUsXHJcbiAgICAgICAgICAgIEJyb3dzZXJUcmFuc2ZlclN0YXRlTW9kdWxlXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgRHhEcmFnZ2FibGVDb21wb25lbnRcclxuICAgICAgICBdLFxyXG4gICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgRHhEcmFnZ2FibGVDb21wb25lbnQsXHJcbiAgICAgICAgICAgIER4b0N1cnNvck9mZnNldE1vZHVsZSxcclxuICAgICAgICAgICAgRHhUZW1wbGF0ZU1vZHVsZVxyXG4gICAgICAgIF1cclxuICAgIH0pXHJcbl0sIER4RHJhZ2dhYmxlTW9kdWxlKTtcclxuZXhwb3J0IHsgRHhEcmFnZ2FibGVNb2R1bGUgfTtcciJdfQ==