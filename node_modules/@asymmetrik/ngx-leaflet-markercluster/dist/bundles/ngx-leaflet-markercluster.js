/*! @asymmetrik/ngx-leaflet-markercluster - 3.0.0 - Copyright Asymmetrik, Ltd. 2007-2019 - All Rights Reserved. + */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@asymmetrik/ngx-leaflet'),exports, require('@angular/core'), require('@asymmetrik/ngx-leaflet'), require('leaflet'), require('leaflet.markercluster')) :
    typeof define === 'function' && define.amd ? define(['@angular/core','@asymmetrik/ngx-leaflet','exports', '@angular/core', '@asymmetrik/ngx-leaflet', 'leaflet', 'leaflet.markercluster'], factory) :
    (global = global || self, factory(global.ng.core,global.asymmetrik.ngxLeaflet,global.ngxLeafletMarkercluster = {}, global.ng.core, global.ngxLeaflet, global.L));
}(this, function (ɵngcc0,ɵngcc1,exports, core, ngxLeaflet, L) { 'use strict';

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var LeafletMarkerClusterDirective = /** @class */ (function () {
        function LeafletMarkerClusterDirective(leafletDirective) {
            // Hexbin data binding
            this.markerData = [];
            // Fired when the marker cluster is created
            this.markerClusterReady = new core.EventEmitter();
            this.leafletDirective = new ngxLeaflet.LeafletDirectiveWrapper(leafletDirective);
        }
        LeafletMarkerClusterDirective.prototype.ngOnInit = function () {
            this.leafletDirective.init();
            var map = this.leafletDirective.getMap();
            this.markerClusterGroup = L.markerClusterGroup(this.markerClusterOptions);
            // Add the marker cluster group to the map
            this.markerClusterGroup.addTo(map);
            // Set the data now that the markerClusterGroup exists
            this.setData(this.markerData);
            // Fire the ready event
            this.markerClusterReady.emit(this.markerClusterGroup);
        };
        LeafletMarkerClusterDirective.prototype.ngOnChanges = function (changes) {
            // Set the new data
            if (changes['markerData']) {
                this.setData(this.markerData);
            }
        };
        LeafletMarkerClusterDirective.prototype.setData = function (layers) {
            // Ignore until the markerClusterGroup exists
            if (null != this.markerClusterGroup) {
                this.markerClusterGroup.clearLayers();
                this.markerClusterGroup.addLayers(layers);
            }
        };
        __decorate([
            core.Input('leafletMarkerCluster'),
            __metadata("design:type", Array)
        ], LeafletMarkerClusterDirective.prototype, "markerData", void 0);
        __decorate([
            core.Input('leafletMarkerClusterOptions'),
            __metadata("design:type", Object)
        ], LeafletMarkerClusterDirective.prototype, "markerClusterOptions", void 0);
        __decorate([
            core.Output('leafletMarkerClusterReady'),
            __metadata("design:type", core.EventEmitter)
        ], LeafletMarkerClusterDirective.prototype, "markerClusterReady", void 0);
        LeafletMarkerClusterDirective = __decorate([ __metadata("design:paramtypes", [ngxLeaflet.LeafletDirective])
        ], LeafletMarkerClusterDirective);
LeafletMarkerClusterDirective.ɵfac = function LeafletMarkerClusterDirective_Factory(t) { return new (t || LeafletMarkerClusterDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LeafletDirective)); };
LeafletMarkerClusterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LeafletMarkerClusterDirective, selectors: [["", "leafletMarkerCluster", ""]], inputs: { markerData: ["leafletMarkerCluster", "markerData"], markerClusterOptions: ["leafletMarkerClusterOptions", "markerClusterOptions"] }, outputs: { markerClusterReady: "leafletMarkerClusterReady" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LeafletMarkerClusterDirective, [{
        type: core.Directive,
        args: [{
                selector: '[leafletMarkerCluster]'
            }]
    }], function () { return [{ type: ɵngcc1.LeafletDirective }]; }, { markerData: [{
            type: core.Input,
            args: ['leafletMarkerCluster']
        }], markerClusterReady: [{
            type: core.Output,
            args: ['leafletMarkerClusterReady']
        }], markerClusterOptions: [{
            type: core.Input,
            args: ['leafletMarkerClusterOptions']
        }] }); })();
        return LeafletMarkerClusterDirective;
    }());

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var LeafletMarkerClusterModule = /** @class */ (function () {
        function LeafletMarkerClusterModule() {
        }
        LeafletMarkerClusterModule_1 = LeafletMarkerClusterModule;
        LeafletMarkerClusterModule.forRoot = function () {
            return { ngModule: LeafletMarkerClusterModule_1, providers: [] };
        };
        var LeafletMarkerClusterModule_1;
LeafletMarkerClusterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LeafletMarkerClusterModule });
LeafletMarkerClusterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LeafletMarkerClusterModule_Factory(t) { return new (t || LeafletMarkerClusterModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LeafletMarkerClusterModule, { declarations: [LeafletMarkerClusterDirective], exports: [LeafletMarkerClusterDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LeafletMarkerClusterModule, [{
        type: core.NgModule,
        args: [{
                exports: [LeafletMarkerClusterDirective],
                declarations: [LeafletMarkerClusterDirective]
            }]
    }], function () { return []; }, null); })();
        return LeafletMarkerClusterModule;
    }());

    exports.LeafletMarkerClusterDirective = LeafletMarkerClusterDirective;
    exports.LeafletMarkerClusterModule = LeafletMarkerClusterModule;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

//# sourceMappingURL=ngx-leaflet-markercluster.js.map