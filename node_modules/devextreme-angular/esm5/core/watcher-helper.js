/*!
 * devextreme-angular
 * Version: 19.2.6
 * Build date: Thu Jan 30 2020
 *
 * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-angular
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import * as commonUtils from 'devextreme/core/utils/common';
import * as ɵngcc0 from '@angular/core';
var WatcherHelper = /** @class */ (function () {
    function WatcherHelper() {
        this._watchers = [];
    }
    WatcherHelper.prototype.getWatchMethod = function () {
        var _this = this;
        var watchMethod = function (valueGetter, valueChangeCallback, options) {
            var oldValue = valueGetter();
            options = options || {};
            if (!options.skipImmediate) {
                valueChangeCallback(oldValue);
            }
            var watcher = function () {
                var newValue = valueGetter();
                if (_this._isDifferentValues(oldValue, newValue, options.deep)) {
                    valueChangeCallback(newValue);
                    oldValue = newValue;
                }
            };
            _this._watchers.push(watcher);
            return function () {
                var index = _this._watchers.indexOf(watcher);
                if (index !== -1) {
                    _this._watchers.splice(index, 1);
                }
            };
        };
        return watchMethod;
    };
    WatcherHelper.prototype._isDifferentValues = function (oldValue, newValue, deepCheck) {
        var comparableNewValue = this._toComparable(newValue);
        var comparableOldValue = this._toComparable(oldValue);
        var isObjectValues = comparableNewValue instanceof Object && comparableOldValue instanceof Object;
        if (deepCheck && isObjectValues) {
            return this._checkObjectsFields(newValue, oldValue);
        }
        return comparableNewValue !== comparableOldValue;
    };
    WatcherHelper.prototype._toComparable = function (value) {
        if (value instanceof Date) {
            return value.getTime();
        }
        return value;
    };
    WatcherHelper.prototype._checkObjectsFields = function (checkingFromObject, checkingToObject) {
        for (var field in checkingFromObject) {
            var oldValue = this._toComparable(checkingFromObject[field]);
            var newValue = this._toComparable(checkingToObject[field]);
            var isEqualObjects = false;
            if (typeof oldValue === 'object' && typeof newValue === 'object') {
                isEqualObjects = commonUtils.equalByValue(oldValue, newValue);
            }
            if (oldValue !== newValue && !isEqualObjects) {
                return true;
            }
        }
    };
    WatcherHelper.prototype.checkWatchers = function () {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(this._watchers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var watcher = _c.value;
                watcher();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
WatcherHelper.ɵfac = function WatcherHelper_Factory(t) { return new (t || WatcherHelper)(); };
WatcherHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: WatcherHelper, factory: function (t) { return WatcherHelper.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WatcherHelper, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return WatcherHelper;
}());
export { WatcherHelper };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wbnNiL0Rlc2t0b3AvTU9BIC0gRS1LQU5NQVMvbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUtYW5ndWxhci9lc201L2NvcmUvd2F0Y2hlci1oZWxwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01Bd0VNOzs7OztnREFHZ0IiLCJmaWxlIjoid2F0Y2hlci1oZWxwZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogZGV2ZXh0cmVtZS1hbmd1bGFyXHJcbiAqIFZlcnNpb246IDE5LjIuNlxyXG4gKiBCdWlsZCBkYXRlOiBUaHUgSmFuIDMwIDIwMjBcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMCBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICpcclxuICogVGhpcyBzb2Z0d2FyZSBtYXkgYmUgbW9kaWZpZWQgYW5kIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtc1xyXG4gKiBvZiB0aGUgTUlUIGxpY2Vuc2UuIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBwcm9qZWN0IGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRGV2RXhwcmVzcy9kZXZleHRyZW1lLWFuZ3VsYXJcclxuICovXHJcbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0ICogYXMgY29tbW9uVXRpbHMgZnJvbSAnZGV2ZXh0cmVtZS9jb3JlL3V0aWxzL2NvbW1vbic7XHJcbnZhciBXYXRjaGVySGVscGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gV2F0Y2hlckhlbHBlcigpIHtcclxuICAgICAgICB0aGlzLl93YXRjaGVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgV2F0Y2hlckhlbHBlci5wcm90b3R5cGUuZ2V0V2F0Y2hNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgd2F0Y2hNZXRob2QgPSBmdW5jdGlvbiAodmFsdWVHZXR0ZXIsIHZhbHVlQ2hhbmdlQ2FsbGJhY2ssIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdmFsdWVHZXR0ZXIoKTtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5za2lwSW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUNoYW5nZUNhbGxiYWNrKG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgd2F0Y2hlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlR2V0dGVyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzRGlmZmVyZW50VmFsdWVzKG9sZFZhbHVlLCBuZXdWYWx1ZSwgb3B0aW9ucy5kZWVwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlQ2FsbGJhY2sobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLl93YXRjaGVycy5wdXNoKHdhdGNoZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3dhdGNoZXJzLmluZGV4T2Yod2F0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dhdGNoZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gd2F0Y2hNZXRob2Q7XHJcbiAgICB9O1xyXG4gICAgV2F0Y2hlckhlbHBlci5wcm90b3R5cGUuX2lzRGlmZmVyZW50VmFsdWVzID0gZnVuY3Rpb24gKG9sZFZhbHVlLCBuZXdWYWx1ZSwgZGVlcENoZWNrKSB7XHJcbiAgICAgICAgdmFyIGNvbXBhcmFibGVOZXdWYWx1ZSA9IHRoaXMuX3RvQ29tcGFyYWJsZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgdmFyIGNvbXBhcmFibGVPbGRWYWx1ZSA9IHRoaXMuX3RvQ29tcGFyYWJsZShvbGRWYWx1ZSk7XHJcbiAgICAgICAgdmFyIGlzT2JqZWN0VmFsdWVzID0gY29tcGFyYWJsZU5ld1ZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmIGNvbXBhcmFibGVPbGRWYWx1ZSBpbnN0YW5jZW9mIE9iamVjdDtcclxuICAgICAgICBpZiAoZGVlcENoZWNrICYmIGlzT2JqZWN0VmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja09iamVjdHNGaWVsZHMobmV3VmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmFibGVOZXdWYWx1ZSAhPT0gY29tcGFyYWJsZU9sZFZhbHVlO1xyXG4gICAgfTtcclxuICAgIFdhdGNoZXJIZWxwZXIucHJvdG90eXBlLl90b0NvbXBhcmFibGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBXYXRjaGVySGVscGVyLnByb3RvdHlwZS5fY2hlY2tPYmplY3RzRmllbGRzID0gZnVuY3Rpb24gKGNoZWNraW5nRnJvbU9iamVjdCwgY2hlY2tpbmdUb09iamVjdCkge1xyXG4gICAgICAgIGZvciAodmFyIGZpZWxkIGluIGNoZWNraW5nRnJvbU9iamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLl90b0NvbXBhcmFibGUoY2hlY2tpbmdGcm9tT2JqZWN0W2ZpZWxkXSk7XHJcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuX3RvQ29tcGFyYWJsZShjaGVja2luZ1RvT2JqZWN0W2ZpZWxkXSk7XHJcbiAgICAgICAgICAgIHZhciBpc0VxdWFsT2JqZWN0cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9sZFZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpc0VxdWFsT2JqZWN0cyA9IGNvbW1vblV0aWxzLmVxdWFsQnlWYWx1ZShvbGRWYWx1ZSwgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUgJiYgIWlzRXF1YWxPYmplY3RzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBXYXRjaGVySGVscGVyLnByb3RvdHlwZS5jaGVja1dhdGNoZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gdHNsaWJfMS5fX3ZhbHVlcyh0aGlzLl93YXRjaGVycyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB3YXRjaGVyID0gX2MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB3YXRjaGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFdhdGNoZXJIZWxwZXIgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUoKVxyXG4gICAgXSwgV2F0Y2hlckhlbHBlcik7XHJcbiAgICByZXR1cm4gV2F0Y2hlckhlbHBlcjtcclxufSgpKTtcclxuZXhwb3J0IHsgV2F0Y2hlckhlbHBlciB9O1xyIl19