/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Output, EventEmitter, Input, HostBinding, ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core';
import { columnsByPin, columnGroupWidths, columnsByPinArr } from '../../utils/column';
import { SortType } from '../../types/sort.type';
import { SelectionType } from '../../types/selection.type';
import { translateXY } from '../../utils/translate';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../../directives/orderable.directive';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from './header-cell.component';
import * as ɵngcc4 from '../../directives/resizeable.directive';
import * as ɵngcc5 from '../../directives/long-press.directive';
import * as ɵngcc6 from '../../directives/draggable.directive';

function DataTableHeaderComponent_div_1_datatable_header_cell_1_Template(rf, ctx) { if (rf & 1) {
    var _r302 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "datatable-header-cell", 4);
    ɵngcc0.ɵɵlistener("resize", function DataTableHeaderComponent_div_1_datatable_header_cell_1_Template_datatable_header_cell_resize_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r302); var column_r300 = ctx.$implicit; var ctx_r301 = ɵngcc0.ɵɵnextContext(2); return ctx_r301.onColumnResized($event, column_r300); })("longPressStart", function DataTableHeaderComponent_div_1_datatable_header_cell_1_Template_datatable_header_cell_longPressStart_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r302); var ctx_r303 = ɵngcc0.ɵɵnextContext(2); return ctx_r303.onLongPressStart($event); })("longPressEnd", function DataTableHeaderComponent_div_1_datatable_header_cell_1_Template_datatable_header_cell_longPressEnd_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r302); var ctx_r304 = ɵngcc0.ɵɵnextContext(2); return ctx_r304.onLongPressEnd($event); })("sort", function DataTableHeaderComponent_div_1_datatable_header_cell_1_Template_datatable_header_cell_sort_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r302); var ctx_r305 = ɵngcc0.ɵɵnextContext(2); return ctx_r305.onSort($event); })("select", function DataTableHeaderComponent_div_1_datatable_header_cell_1_Template_datatable_header_cell_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r302); var ctx_r306 = ɵngcc0.ɵɵnextContext(2); return ctx_r306.select.emit($event); })("columnContextmenu", function DataTableHeaderComponent_div_1_datatable_header_cell_1_Template_datatable_header_cell_columnContextmenu_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r302); var ctx_r307 = ɵngcc0.ɵɵnextContext(2); return ctx_r307.columnContextmenu.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var column_r300 = ctx.$implicit;
    var ctx_r299 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("resizeEnabled", column_r300.resizeable)("pressModel", column_r300)("pressEnabled", ctx_r299.reorderable && column_r300.draggable)("dragX", ctx_r299.reorderable && column_r300.draggable && column_r300.dragging)("dragY", false)("dragModel", column_r300)("dragEventTarget", ctx_r299.dragEventTarget)("headerHeight", ctx_r299.headerHeight)("isTarget", column_r300.isTarget)("targetMarkerTemplate", ctx_r299.targetMarkerTemplate)("targetMarkerContext", column_r300.targetMarkerContext)("column", column_r300)("sortType", ctx_r299.sortType)("sorts", ctx_r299.sorts)("selectionType", ctx_r299.selectionType)("sortAscendingIcon", ctx_r299.sortAscendingIcon)("sortDescendingIcon", ctx_r299.sortDescendingIcon)("allRowsSelected", ctx_r299.allRowsSelected);
} }
function DataTableHeaderComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵtemplate(1, DataTableHeaderComponent_div_1_datatable_header_cell_1_Template, 1, 18, "datatable-header-cell", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var colGroup_r298 = ctx.$implicit;
    var ctx_r297 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap("datatable-row-" + colGroup_r298.type);
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r297._styleByGroup[colGroup_r298.type]);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", colGroup_r298.columns)("ngForTrackBy", ctx_r297.columnTrackingFn);
} }
var DataTableHeaderComponent = /** @class */ (function () {
    function DataTableHeaderComponent(cd) {
        this.cd = cd;
        this.sort = new EventEmitter();
        this.reorder = new EventEmitter();
        this.resize = new EventEmitter();
        this.select = new EventEmitter();
        this.columnContextmenu = new EventEmitter(false);
        this._columnGroupWidths = {
            total: 100
        };
        this._styleByGroup = {
            left: {},
            center: {},
            right: {}
        };
        this.destroyed = false;
    }
    Object.defineProperty(DataTableHeaderComponent.prototype, "innerWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this._innerWidth;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            this._innerWidth = val;
            setTimeout((/**
             * @return {?}
             */
            function () {
                if (_this._columns) {
                    /** @type {?} */
                    var colByPin = columnsByPin(_this._columns);
                    _this._columnGroupWidths = columnGroupWidths(colByPin, _this._columns);
                    _this.setStylesByGroup();
                }
            }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableHeaderComponent.prototype, "headerHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this._headerHeight;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val !== 'auto') {
                this._headerHeight = val + "px";
            }
            else {
                this._headerHeight = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableHeaderComponent.prototype, "columns", {
        get: /**
         * @return {?}
         */
        function () {
            return this._columns;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            this._columns = val;
            /** @type {?} */
            var colsByPin = columnsByPin(val);
            this._columnsByPin = columnsByPinArr(val);
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this._columnGroupWidths = columnGroupWidths(colsByPin, val);
                _this.setStylesByGroup();
            }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataTableHeaderComponent.prototype, "offsetX", {
        get: /**
         * @return {?}
         */
        function () {
            return this._offsetX;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._offsetX = val;
            this.setStylesByGroup();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DataTableHeaderComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroyed = true;
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    DataTableHeaderComponent.prototype.onLongPressStart = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var event = _a.event, model = _a.model;
        model.dragging = true;
        this.dragEventTarget = event;
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    DataTableHeaderComponent.prototype.onLongPressEnd = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var _this = this;
        var event = _a.event, model = _a.model;
        this.dragEventTarget = event;
        // delay resetting so sort can be
        // prevented if we were dragging
        setTimeout((/**
         * @return {?}
         */
        function () {
            // datatable component creates copies from columns on reorder
            // set dragging to false on new objects
            /** @type {?} */
            var column = _this._columns.find((/**
             * @param {?} c
             * @return {?}
             */
            function (c) { return c.$$id === model.$$id; }));
            if (column) {
                column.dragging = false;
            }
        }), 5);
    };
    Object.defineProperty(DataTableHeaderComponent.prototype, "headerWidth", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.scrollbarH) {
                return this.innerWidth + 'px';
            }
            return '100%';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} index
     * @param {?} colGroup
     * @return {?}
     */
    DataTableHeaderComponent.prototype.trackByGroups = /**
     * @param {?} index
     * @param {?} colGroup
     * @return {?}
     */
    function (index, colGroup) {
        return colGroup.type;
    };
    /**
     * @param {?} index
     * @param {?} column
     * @return {?}
     */
    DataTableHeaderComponent.prototype.columnTrackingFn = /**
     * @param {?} index
     * @param {?} column
     * @return {?}
     */
    function (index, column) {
        return column.$$id;
    };
    /**
     * @param {?} width
     * @param {?} column
     * @return {?}
     */
    DataTableHeaderComponent.prototype.onColumnResized = /**
     * @param {?} width
     * @param {?} column
     * @return {?}
     */
    function (width, column) {
        if (width <= column.minWidth) {
            width = column.minWidth;
        }
        else if (width >= column.maxWidth) {
            width = column.maxWidth;
        }
        this.resize.emit({
            column: column,
            prevValue: column.width,
            newValue: width
        });
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    DataTableHeaderComponent.prototype.onColumnReordered = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var prevIndex = _a.prevIndex, newIndex = _a.newIndex, model = _a.model;
        /** @type {?} */
        var column = this.getColumn(newIndex);
        column.isTarget = false;
        column.targetMarkerContext = undefined;
        this.reorder.emit({
            column: model,
            prevValue: prevIndex,
            newValue: newIndex
        });
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    DataTableHeaderComponent.prototype.onTargetChanged = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var prevIndex = _a.prevIndex, newIndex = _a.newIndex, initialIndex = _a.initialIndex;
        if (prevIndex || prevIndex === 0) {
            /** @type {?} */
            var oldColumn = this.getColumn(prevIndex);
            oldColumn.isTarget = false;
            oldColumn.targetMarkerContext = undefined;
        }
        if (newIndex || newIndex === 0) {
            /** @type {?} */
            var newColumn = this.getColumn(newIndex);
            newColumn.isTarget = true;
            if (initialIndex !== newIndex) {
                newColumn.targetMarkerContext = {
                    class: 'targetMarker '.concat(initialIndex > newIndex ? 'dragFromRight' : 'dragFromLeft')
                };
            }
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    DataTableHeaderComponent.prototype.getColumn = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var leftColumnCount = this._columnsByPin[0].columns.length;
        if (index < leftColumnCount) {
            return this._columnsByPin[0].columns[index];
        }
        /** @type {?} */
        var centerColumnCount = this._columnsByPin[1].columns.length;
        if (index < leftColumnCount + centerColumnCount) {
            return this._columnsByPin[1].columns[index - leftColumnCount];
        }
        return this._columnsByPin[2].columns[index - leftColumnCount - centerColumnCount];
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    DataTableHeaderComponent.prototype.onSort = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var column = _a.column, prevValue = _a.prevValue, newValue = _a.newValue;
        // if we are dragging don't sort!
        if (column.dragging) {
            return;
        }
        /** @type {?} */
        var sorts = this.calcNewSorts(column, prevValue, newValue);
        this.sort.emit({
            sorts: sorts,
            column: column,
            prevValue: prevValue,
            newValue: newValue
        });
    };
    /**
     * @param {?} column
     * @param {?} prevValue
     * @param {?} newValue
     * @return {?}
     */
    DataTableHeaderComponent.prototype.calcNewSorts = /**
     * @param {?} column
     * @param {?} prevValue
     * @param {?} newValue
     * @return {?}
     */
    function (column, prevValue, newValue) {
        /** @type {?} */
        var idx = 0;
        if (!this.sorts) {
            this.sorts = [];
        }
        /** @type {?} */
        var sorts = this.sorts.map((/**
         * @param {?} s
         * @param {?} i
         * @return {?}
         */
        function (s, i) {
            s = tslib_1.__assign({}, s);
            if (s.prop === column.prop) {
                idx = i;
            }
            return s;
        }));
        if (newValue === undefined) {
            sorts.splice(idx, 1);
        }
        else if (prevValue) {
            sorts[idx].dir = newValue;
        }
        else {
            if (this.sortType === SortType.single) {
                sorts.splice(0, this.sorts.length);
            }
            sorts.push({ dir: newValue, prop: column.prop });
        }
        return sorts;
    };
    /**
     * @return {?}
     */
    DataTableHeaderComponent.prototype.setStylesByGroup = /**
     * @return {?}
     */
    function () {
        this._styleByGroup.left = this.calcStylesByGroup('left');
        this._styleByGroup.center = this.calcStylesByGroup('center');
        this._styleByGroup.right = this.calcStylesByGroup('right');
        if (!this.destroyed) {
            this.cd.detectChanges();
        }
    };
    /**
     * @param {?} group
     * @return {?}
     */
    DataTableHeaderComponent.prototype.calcStylesByGroup = /**
     * @param {?} group
     * @return {?}
     */
    function (group) {
        /** @type {?} */
        var widths = this._columnGroupWidths;
        /** @type {?} */
        var offsetX = this.offsetX;
        /** @type {?} */
        var styles = {
            width: widths[group] + "px"
        };
        if (group === 'center') {
            translateXY(styles, offsetX * -1, 0);
        }
        else if (group === 'right') {
            /** @type {?} */
            var totalDiff = widths.total - this.innerWidth;
            /** @type {?} */
            var offset = totalDiff * -1;
            translateXY(styles, offset, 0);
        }
        return styles;
    };
    /** @nocollapse */
    DataTableHeaderComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    DataTableHeaderComponent.propDecorators = {
        sortAscendingIcon: [{ type: Input }],
        sortDescendingIcon: [{ type: Input }],
        scrollbarH: [{ type: Input }],
        dealsWithGroup: [{ type: Input }],
        targetMarkerTemplate: [{ type: Input }],
        innerWidth: [{ type: Input }],
        sorts: [{ type: Input }],
        sortType: [{ type: Input }],
        allRowsSelected: [{ type: Input }],
        selectionType: [{ type: Input }],
        reorderable: [{ type: Input }],
        headerHeight: [{ type: HostBinding, args: ['style.height',] }, { type: Input }],
        columns: [{ type: Input }],
        offsetX: [{ type: Input }],
        sort: [{ type: Output }],
        reorder: [{ type: Output }],
        resize: [{ type: Output }],
        select: [{ type: Output }],
        columnContextmenu: [{ type: Output }],
        headerWidth: [{ type: HostBinding, args: ['style.width',] }]
    };
DataTableHeaderComponent.ɵfac = function DataTableHeaderComponent_Factory(t) { return new (t || DataTableHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
DataTableHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DataTableHeaderComponent, selectors: [["datatable-header"]], hostAttrs: [1, "datatable-header"], hostVars: 4, hostBindings: function DataTableHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.headerHeight)("width", ctx.headerWidth);
    } }, inputs: { innerWidth: "innerWidth", headerHeight: "headerHeight", columns: "columns", offsetX: "offsetX", sorts: "sorts", sortAscendingIcon: "sortAscendingIcon", sortDescendingIcon: "sortDescendingIcon", scrollbarH: "scrollbarH", dealsWithGroup: "dealsWithGroup", targetMarkerTemplate: "targetMarkerTemplate", sortType: "sortType", allRowsSelected: "allRowsSelected", selectionType: "selectionType", reorderable: "reorderable" }, outputs: { sort: "sort", reorder: "reorder", resize: "resize", select: "select", columnContextmenu: "columnContextmenu" }, decls: 2, vars: 4, consts: [["orderable", "", 1, "datatable-header-inner", 3, "reorder", "targetChanged"], [3, "class", "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngStyle"], ["resizeable", "", "long-press", "", "draggable", "", 3, "resizeEnabled", "pressModel", "pressEnabled", "dragX", "dragY", "dragModel", "dragEventTarget", "headerHeight", "isTarget", "targetMarkerTemplate", "targetMarkerContext", "column", "sortType", "sorts", "selectionType", "sortAscendingIcon", "sortDescendingIcon", "allRowsSelected", "resize", "longPressStart", "longPressEnd", "sort", "select", "columnContextmenu", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["resizeable", "", "long-press", "", "draggable", "", 3, "resizeEnabled", "pressModel", "pressEnabled", "dragX", "dragY", "dragModel", "dragEventTarget", "headerHeight", "isTarget", "targetMarkerTemplate", "targetMarkerContext", "column", "sortType", "sorts", "selectionType", "sortAscendingIcon", "sortDescendingIcon", "allRowsSelected", "resize", "longPressStart", "longPressEnd", "sort", "select", "columnContextmenu"]], template: function DataTableHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("reorder", function DataTableHeaderComponent_Template_div_reorder_0_listener($event) { return ctx.onColumnReordered($event); })("targetChanged", function DataTableHeaderComponent_Template_div_targetChanged_0_listener($event) { return ctx.onTargetChanged($event); });
        ɵngcc0.ɵɵtemplate(1, DataTableHeaderComponent_div_1_Template, 2, 5, "div", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx._columnGroupWidths.total, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx._columnsByPin)("ngForTrackBy", ctx.trackByGroups);
    } }, directives: [ɵngcc1.OrderableDirective, ɵngcc2.NgForOf, ɵngcc2.NgStyle, ɵngcc3.DataTableHeaderCellComponent, ɵngcc4.ResizeableDirective, ɵngcc5.LongPressDirective, ɵngcc6.DraggableDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DataTableHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'datatable-header',
                template: "\n    <div\n      orderable\n      (reorder)=\"onColumnReordered($event)\"\n      (targetChanged)=\"onTargetChanged($event)\"\n      [style.width.px]=\"_columnGroupWidths.total\"\n      class=\"datatable-header-inner\"\n    >\n      <div\n        *ngFor=\"let colGroup of _columnsByPin; trackBy: trackByGroups\"\n        [class]=\"'datatable-row-' + colGroup.type\"\n        [ngStyle]=\"_styleByGroup[colGroup.type]\"\n      >\n        <datatable-header-cell\n          *ngFor=\"let column of colGroup.columns; trackBy: columnTrackingFn\"\n          resizeable\n          [resizeEnabled]=\"column.resizeable\"\n          (resize)=\"onColumnResized($event, column)\"\n          long-press\n          [pressModel]=\"column\"\n          [pressEnabled]=\"reorderable && column.draggable\"\n          (longPressStart)=\"onLongPressStart($event)\"\n          (longPressEnd)=\"onLongPressEnd($event)\"\n          draggable\n          [dragX]=\"reorderable && column.draggable && column.dragging\"\n          [dragY]=\"false\"\n          [dragModel]=\"column\"\n          [dragEventTarget]=\"dragEventTarget\"\n          [headerHeight]=\"headerHeight\"\n          [isTarget]=\"column.isTarget\"\n          [targetMarkerTemplate]=\"targetMarkerTemplate\"\n          [targetMarkerContext]=\"column.targetMarkerContext\"\n          [column]=\"column\"\n          [sortType]=\"sortType\"\n          [sorts]=\"sorts\"\n          [selectionType]=\"selectionType\"\n          [sortAscendingIcon]=\"sortAscendingIcon\"\n          [sortDescendingIcon]=\"sortDescendingIcon\"\n          [allRowsSelected]=\"allRowsSelected\"\n          (sort)=\"onSort($event)\"\n          (select)=\"select.emit($event)\"\n          (columnContextmenu)=\"columnContextmenu.emit($event)\"\n        >\n        </datatable-header-cell>\n      </div>\n    </div>\n  ",
                host: {
                    class: 'datatable-header'
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { sort: [{
            type: Output
        }], reorder: [{
            type: Output
        }], resize: [{
            type: Output
        }], select: [{
            type: Output
        }], columnContextmenu: [{
            type: Output
        }], innerWidth: [{
            type: Input
        }], headerHeight: [{
            type: HostBinding,
            args: ['style.height']
        }, {
            type: Input
        }], columns: [{
            type: Input
        }], offsetX: [{
            type: Input
        }], headerWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], sorts: [{
            type: Input
        }], sortAscendingIcon: [{
            type: Input
        }], sortDescendingIcon: [{
            type: Input
        }], scrollbarH: [{
            type: Input
        }], dealsWithGroup: [{
            type: Input
        }], targetMarkerTemplate: [{
            type: Input
        }], sortType: [{
            type: Input
        }], allRowsSelected: [{
            type: Input
        }], selectionType: [{
            type: Input
        }], reorderable: [{
            type: Input
        }] }); })();
    return DataTableHeaderComponent;
}());
export { DataTableHeaderComponent };
if (false) {
    /** @type {?} */
    DataTableHeaderComponent.prototype.sortAscendingIcon;
    /** @type {?} */
    DataTableHeaderComponent.prototype.sortDescendingIcon;
    /** @type {?} */
    DataTableHeaderComponent.prototype.scrollbarH;
    /** @type {?} */
    DataTableHeaderComponent.prototype.dealsWithGroup;
    /** @type {?} */
    DataTableHeaderComponent.prototype.targetMarkerTemplate;
    /** @type {?} */
    DataTableHeaderComponent.prototype.targetMarkerContext;
    /** @type {?} */
    DataTableHeaderComponent.prototype.sorts;
    /** @type {?} */
    DataTableHeaderComponent.prototype.sortType;
    /** @type {?} */
    DataTableHeaderComponent.prototype.allRowsSelected;
    /** @type {?} */
    DataTableHeaderComponent.prototype.selectionType;
    /** @type {?} */
    DataTableHeaderComponent.prototype.reorderable;
    /** @type {?} */
    DataTableHeaderComponent.prototype.dragEventTarget;
    /** @type {?} */
    DataTableHeaderComponent.prototype.sort;
    /** @type {?} */
    DataTableHeaderComponent.prototype.reorder;
    /** @type {?} */
    DataTableHeaderComponent.prototype.resize;
    /** @type {?} */
    DataTableHeaderComponent.prototype.select;
    /** @type {?} */
    DataTableHeaderComponent.prototype.columnContextmenu;
    /** @type {?} */
    DataTableHeaderComponent.prototype._columnsByPin;
    /** @type {?} */
    DataTableHeaderComponent.prototype._columnGroupWidths;
    /** @type {?} */
    DataTableHeaderComponent.prototype._innerWidth;
    /** @type {?} */
    DataTableHeaderComponent.prototype._offsetX;
    /** @type {?} */
    DataTableHeaderComponent.prototype._columns;
    /** @type {?} */
    DataTableHeaderComponent.prototype._headerHeight;
    /** @type {?} */
    DataTableHeaderComponent.prototype._styleByGroup;
    /**
     * @type {?}
     * @private
     */
    DataTableHeaderComponent.prototype.destroyed;
    /**
     * @type {?}
     * @private
     */
    DataTableHeaderComponent.prototype.cd;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wbnNiL0Rlc2t0b3AvTU9BIC0gRS1LQU5NQVMvbm9kZV9tb2R1bGVzL0Bzd2ltbGFuZS9uZ3gtZGF0YXRhYmxlL2VzbTUvbGliL2NvbXBvbmVudHMvaGVhZGVyL2hlYWRlci5jb21wb25lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01Bd1pNLEFBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBMEJBIiwiZmlsZSI6ImhlYWRlci5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGNvbnN0YW50UHJvcGVydHksZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIEhvc3RCaW5kaW5nLCBDaGFuZ2VEZXRlY3RvclJlZiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNvbHVtbnNCeVBpbiwgY29sdW1uR3JvdXBXaWR0aHMsIGNvbHVtbnNCeVBpbkFyciB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbHVtbic7XG5pbXBvcnQgeyBTb3J0VHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzL3NvcnQudHlwZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25UeXBlIH0gZnJvbSAnLi4vLi4vdHlwZXMvc2VsZWN0aW9uLnR5cGUnO1xuaW1wb3J0IHsgdHJhbnNsYXRlWFkgfSBmcm9tICcuLi8uLi91dGlscy90cmFuc2xhdGUnO1xudmFyIERhdGFUYWJsZUhlYWRlckNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQoY2QpIHtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLnNvcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucmVvcmRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yZXNpemUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvbHVtbkNvbnRleHRtZW51ID0gbmV3IEV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgIHRoaXMuX2NvbHVtbkdyb3VwV2lkdGhzID0ge1xuICAgICAgICAgICAgdG90YWw6IDEwMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zdHlsZUJ5R3JvdXAgPSB7XG4gICAgICAgICAgICBsZWZ0OiB7fSxcbiAgICAgICAgICAgIGNlbnRlcjoge30sXG4gICAgICAgICAgICByaWdodDoge31cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJXaWR0aFwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJXaWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9pbm5lcldpZHRoID0gdmFsO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbEJ5UGluID0gY29sdW1uc0J5UGluKF90aGlzLl9jb2x1bW5zKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NvbHVtbkdyb3VwV2lkdGhzID0gY29sdW1uR3JvdXBXaWR0aHMoY29sQnlQaW4sIF90aGlzLl9jb2x1bW5zKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3R5bGVzQnlHcm91cCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVhZGVySGVpZ2h0XCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJIZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJIZWlnaHQgPSB2YWwgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJIZWlnaHQgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbnNcIiwge1xuICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fY29sdW1ucyA9IHZhbDtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBjb2xzQnlQaW4gPSBjb2x1bW5zQnlQaW4odmFsKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbnNCeVBpbiA9IGNvbHVtbnNCeVBpbkFycih2YWwpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbHVtbkdyb3VwV2lkdGhzID0gY29sdW1uR3JvdXBXaWR0aHMoY29sc0J5UGluLCB2YWwpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0eWxlc0J5R3JvdXAoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib2Zmc2V0WFwiLCB7XG4gICAgICAgIGdldDogLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFggPSB2YWw7XG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlc0J5R3JvdXAoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLm9uTG9uZ1ByZXNzU3RhcnQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBldmVudCA9IF9hLmV2ZW50LCBtb2RlbCA9IF9hLm1vZGVsO1xuICAgICAgICBtb2RlbC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZHJhZ0V2ZW50VGFyZ2V0ID0gZXZlbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5vbkxvbmdQcmVzc0VuZCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50ID0gX2EuZXZlbnQsIG1vZGVsID0gX2EubW9kZWw7XG4gICAgICAgIHRoaXMuZHJhZ0V2ZW50VGFyZ2V0ID0gZXZlbnQ7XG4gICAgICAgIC8vIGRlbGF5IHJlc2V0dGluZyBzbyBzb3J0IGNhbiBiZVxuICAgICAgICAvLyBwcmV2ZW50ZWQgaWYgd2Ugd2VyZSBkcmFnZ2luZ1xuICAgICAgICBzZXRUaW1lb3V0KCgvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGRhdGF0YWJsZSBjb21wb25lbnQgY3JlYXRlcyBjb3BpZXMgZnJvbSBjb2x1bW5zIG9uIHJlb3JkZXJcbiAgICAgICAgICAgIC8vIHNldCBkcmFnZ2luZyB0byBmYWxzZSBvbiBuZXcgb2JqZWN0c1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IF90aGlzLl9jb2x1bW5zLmZpbmQoKC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBjXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy4kJGlkID09PSBtb2RlbC4kJGlkOyB9KSk7XG4gICAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCA1KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhlYWRlcldpZHRoXCIsIHtcbiAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbGJhckgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lcldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnMTAwJSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcGFyYW0gez99IGNvbEdyb3VwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnlHcm91cHMgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/fSBjb2xHcm91cFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGluZGV4LCBjb2xHcm91cCkge1xuICAgICAgICByZXR1cm4gY29sR3JvdXAudHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcGFyYW0gez99IGNvbHVtblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5jb2x1bW5UcmFja2luZ0ZuID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7P30gY29sdW1uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5kZXgsIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gY29sdW1uLiQkaWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHdpZHRoXG4gICAgICogQHBhcmFtIHs/fSBjb2x1bW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUub25Db2x1bW5SZXNpemVkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB3aWR0aFxuICAgICAqIEBwYXJhbSB7P30gY29sdW1uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAod2lkdGgsIGNvbHVtbikge1xuICAgICAgICBpZiAod2lkdGggPD0gY29sdW1uLm1pbldpZHRoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGNvbHVtbi5taW5XaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aWR0aCA+PSBjb2x1bW4ubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gY29sdW1uLm1heFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplLmVtaXQoe1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBwcmV2VmFsdWU6IGNvbHVtbi53aWR0aCxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiB3aWR0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLm9uQ29sdW1uUmVvcmRlcmVkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBfXzBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gX2EucHJldkluZGV4LCBuZXdJbmRleCA9IF9hLm5ld0luZGV4LCBtb2RlbCA9IF9hLm1vZGVsO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldENvbHVtbihuZXdJbmRleCk7XG4gICAgICAgIGNvbHVtbi5pc1RhcmdldCA9IGZhbHNlO1xuICAgICAgICBjb2x1bW4udGFyZ2V0TWFya2VyQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZW9yZGVyLmVtaXQoe1xuICAgICAgICAgICAgY29sdW1uOiBtb2RlbCxcbiAgICAgICAgICAgIHByZXZWYWx1ZTogcHJldkluZGV4LFxuICAgICAgICAgICAgbmV3VmFsdWU6IG5ld0luZGV4XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfXzBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUub25UYXJnZXRDaGFuZ2VkID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBfXzBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gX2EucHJldkluZGV4LCBuZXdJbmRleCA9IF9hLm5ld0luZGV4LCBpbml0aWFsSW5kZXggPSBfYS5pbml0aWFsSW5kZXg7XG4gICAgICAgIGlmIChwcmV2SW5kZXggfHwgcHJldkluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgb2xkQ29sdW1uID0gdGhpcy5nZXRDb2x1bW4ocHJldkluZGV4KTtcbiAgICAgICAgICAgIG9sZENvbHVtbi5pc1RhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgb2xkQ29sdW1uLnRhcmdldE1hcmtlckNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0luZGV4IHx8IG5ld0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgbmV3Q29sdW1uID0gdGhpcy5nZXRDb2x1bW4obmV3SW5kZXgpO1xuICAgICAgICAgICAgbmV3Q29sdW1uLmlzVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsSW5kZXggIT09IG5ld0luZGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3Q29sdW1uLnRhcmdldE1hcmtlckNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAndGFyZ2V0TWFya2VyICcuY29uY2F0KGluaXRpYWxJbmRleCA+IG5ld0luZGV4ID8gJ2RyYWdGcm9tUmlnaHQnIDogJ2RyYWdGcm9tTGVmdCcpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDb2x1bW4gPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgbGVmdENvbHVtbkNvdW50ID0gdGhpcy5fY29sdW1uc0J5UGluWzBdLmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICBpZiAoaW5kZXggPCBsZWZ0Q29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zQnlQaW5bMF0uY29sdW1uc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgY2VudGVyQ29sdW1uQ291bnQgPSB0aGlzLl9jb2x1bW5zQnlQaW5bMV0uY29sdW1ucy5sZW5ndGg7XG4gICAgICAgIGlmIChpbmRleCA8IGxlZnRDb2x1bW5Db3VudCArIGNlbnRlckNvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uc0J5UGluWzFdLmNvbHVtbnNbaW5kZXggLSBsZWZ0Q29sdW1uQ291bnRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zQnlQaW5bMl0uY29sdW1uc1tpbmRleCAtIGxlZnRDb2x1bW5Db3VudCAtIGNlbnRlckNvbHVtbkNvdW50XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLm9uU29ydCA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IF9hLmNvbHVtbiwgcHJldlZhbHVlID0gX2EucHJldlZhbHVlLCBuZXdWYWx1ZSA9IF9hLm5ld1ZhbHVlO1xuICAgICAgICAvLyBpZiB3ZSBhcmUgZHJhZ2dpbmcgZG9uJ3Qgc29ydCFcbiAgICAgICAgaWYgKGNvbHVtbi5kcmFnZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHNvcnRzID0gdGhpcy5jYWxjTmV3U29ydHMoY29sdW1uLCBwcmV2VmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5zb3J0LmVtaXQoe1xuICAgICAgICAgICAgc29ydHM6IHNvcnRzLFxuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBwcmV2VmFsdWU6IHByZXZWYWx1ZSxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29sdW1uXG4gICAgICogQHBhcmFtIHs/fSBwcmV2VmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5ld1ZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLmNhbGNOZXdTb3J0cyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29sdW1uXG4gICAgICogQHBhcmFtIHs/fSBwcmV2VmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5ld1ZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY29sdW1uLCBwcmV2VmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIGlmICghdGhpcy5zb3J0cykge1xuICAgICAgICAgICAgdGhpcy5zb3J0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHNvcnRzID0gdGhpcy5zb3J0cy5tYXAoKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNcbiAgICAgICAgICogQHBhcmFtIHs/fSBpXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgICAgcyA9IHRzbGliXzEuX19hc3NpZ24oe30sIHMpO1xuICAgICAgICAgICAgaWYgKHMucHJvcCA9PT0gY29sdW1uLnByb3ApIHtcbiAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNvcnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZWYWx1ZSkge1xuICAgICAgICAgICAgc29ydHNbaWR4XS5kaXIgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvcnRUeXBlID09PSBTb3J0VHlwZS5zaW5nbGUpIHtcbiAgICAgICAgICAgICAgICBzb3J0cy5zcGxpY2UoMCwgdGhpcy5zb3J0cy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ydHMucHVzaCh7IGRpcjogbmV3VmFsdWUsIHByb3A6IGNvbHVtbi5wcm9wIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3J0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdHlsZXNCeUdyb3VwID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0eWxlQnlHcm91cC5sZWZ0ID0gdGhpcy5jYWxjU3R5bGVzQnlHcm91cCgnbGVmdCcpO1xuICAgICAgICB0aGlzLl9zdHlsZUJ5R3JvdXAuY2VudGVyID0gdGhpcy5jYWxjU3R5bGVzQnlHcm91cCgnY2VudGVyJyk7XG4gICAgICAgIHRoaXMuX3N0eWxlQnlHcm91cC5yaWdodCA9IHRoaXMuY2FsY1N0eWxlc0J5R3JvdXAoJ3JpZ2h0Jyk7XG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGdyb3VwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLmNhbGNTdHlsZXNCeUdyb3VwID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBncm91cFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIHdpZHRocyA9IHRoaXMuX2NvbHVtbkdyb3VwV2lkdGhzO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBvZmZzZXRYID0gdGhpcy5vZmZzZXRYO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGhzW2dyb3VwXSArIFwicHhcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAoZ3JvdXAgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVYWShzdHlsZXMsIG9mZnNldFggKiAtMSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3JvdXAgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciB0b3RhbERpZmYgPSB3aWR0aHMudG90YWwgLSB0aGlzLmlubmVyV2lkdGg7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdG90YWxEaWZmICogLTE7XG4gICAgICAgICAgICB0cmFuc2xhdGVYWShzdHlsZXMsIG9mZnNldCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9O1xuICAgIERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdkYXRhdGFibGUtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXZcXG4gICAgICBvcmRlcmFibGVcXG4gICAgICAocmVvcmRlcik9XFxcIm9uQ29sdW1uUmVvcmRlcmVkKCRldmVudClcXFwiXFxuICAgICAgKHRhcmdldENoYW5nZWQpPVxcXCJvblRhcmdldENoYW5nZWQoJGV2ZW50KVxcXCJcXG4gICAgICBbc3R5bGUud2lkdGgucHhdPVxcXCJfY29sdW1uR3JvdXBXaWR0aHMudG90YWxcXFwiXFxuICAgICAgY2xhc3M9XFxcImRhdGF0YWJsZS1oZWFkZXItaW5uZXJcXFwiXFxuICAgID5cXG4gICAgICA8ZGl2XFxuICAgICAgICAqbmdGb3I9XFxcImxldCBjb2xHcm91cCBvZiBfY29sdW1uc0J5UGluOyB0cmFja0J5OiB0cmFja0J5R3JvdXBzXFxcIlxcbiAgICAgICAgW2NsYXNzXT1cXFwiJ2RhdGF0YWJsZS1yb3ctJyArIGNvbEdyb3VwLnR5cGVcXFwiXFxuICAgICAgICBbbmdTdHlsZV09XFxcIl9zdHlsZUJ5R3JvdXBbY29sR3JvdXAudHlwZV1cXFwiXFxuICAgICAgPlxcbiAgICAgICAgPGRhdGF0YWJsZS1oZWFkZXItY2VsbFxcbiAgICAgICAgICAqbmdGb3I9XFxcImxldCBjb2x1bW4gb2YgY29sR3JvdXAuY29sdW1uczsgdHJhY2tCeTogY29sdW1uVHJhY2tpbmdGblxcXCJcXG4gICAgICAgICAgcmVzaXplYWJsZVxcbiAgICAgICAgICBbcmVzaXplRW5hYmxlZF09XFxcImNvbHVtbi5yZXNpemVhYmxlXFxcIlxcbiAgICAgICAgICAocmVzaXplKT1cXFwib25Db2x1bW5SZXNpemVkKCRldmVudCwgY29sdW1uKVxcXCJcXG4gICAgICAgICAgbG9uZy1wcmVzc1xcbiAgICAgICAgICBbcHJlc3NNb2RlbF09XFxcImNvbHVtblxcXCJcXG4gICAgICAgICAgW3ByZXNzRW5hYmxlZF09XFxcInJlb3JkZXJhYmxlICYmIGNvbHVtbi5kcmFnZ2FibGVcXFwiXFxuICAgICAgICAgIChsb25nUHJlc3NTdGFydCk9XFxcIm9uTG9uZ1ByZXNzU3RhcnQoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGxvbmdQcmVzc0VuZCk9XFxcIm9uTG9uZ1ByZXNzRW5kKCRldmVudClcXFwiXFxuICAgICAgICAgIGRyYWdnYWJsZVxcbiAgICAgICAgICBbZHJhZ1hdPVxcXCJyZW9yZGVyYWJsZSAmJiBjb2x1bW4uZHJhZ2dhYmxlICYmIGNvbHVtbi5kcmFnZ2luZ1xcXCJcXG4gICAgICAgICAgW2RyYWdZXT1cXFwiZmFsc2VcXFwiXFxuICAgICAgICAgIFtkcmFnTW9kZWxdPVxcXCJjb2x1bW5cXFwiXFxuICAgICAgICAgIFtkcmFnRXZlbnRUYXJnZXRdPVxcXCJkcmFnRXZlbnRUYXJnZXRcXFwiXFxuICAgICAgICAgIFtoZWFkZXJIZWlnaHRdPVxcXCJoZWFkZXJIZWlnaHRcXFwiXFxuICAgICAgICAgIFtpc1RhcmdldF09XFxcImNvbHVtbi5pc1RhcmdldFxcXCJcXG4gICAgICAgICAgW3RhcmdldE1hcmtlclRlbXBsYXRlXT1cXFwidGFyZ2V0TWFya2VyVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFt0YXJnZXRNYXJrZXJDb250ZXh0XT1cXFwiY29sdW1uLnRhcmdldE1hcmtlckNvbnRleHRcXFwiXFxuICAgICAgICAgIFtjb2x1bW5dPVxcXCJjb2x1bW5cXFwiXFxuICAgICAgICAgIFtzb3J0VHlwZV09XFxcInNvcnRUeXBlXFxcIlxcbiAgICAgICAgICBbc29ydHNdPVxcXCJzb3J0c1xcXCJcXG4gICAgICAgICAgW3NlbGVjdGlvblR5cGVdPVxcXCJzZWxlY3Rpb25UeXBlXFxcIlxcbiAgICAgICAgICBbc29ydEFzY2VuZGluZ0ljb25dPVxcXCJzb3J0QXNjZW5kaW5nSWNvblxcXCJcXG4gICAgICAgICAgW3NvcnREZXNjZW5kaW5nSWNvbl09XFxcInNvcnREZXNjZW5kaW5nSWNvblxcXCJcXG4gICAgICAgICAgW2FsbFJvd3NTZWxlY3RlZF09XFxcImFsbFJvd3NTZWxlY3RlZFxcXCJcXG4gICAgICAgICAgKHNvcnQpPVxcXCJvblNvcnQoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKHNlbGVjdCk9XFxcInNlbGVjdC5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAgIChjb2x1bW5Db250ZXh0bWVudSk9XFxcImNvbHVtbkNvbnRleHRtZW51LmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgIDwvZGF0YXRhYmxlLWhlYWRlci1jZWxsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIFwiLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2RhdGF0YWJsZS1oZWFkZXInXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICAgICAgfV0gfVxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbiAgICBdOyB9O1xuICAgIERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgc29ydEFzY2VuZGluZ0ljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBzb3J0RGVzY2VuZGluZ0ljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBzY3JvbGxiYXJIOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgZGVhbHNXaXRoR3JvdXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICB0YXJnZXRNYXJrZXJUZW1wbGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGlubmVyV2lkdGg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBzb3J0czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHNvcnRUeXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgYWxsUm93c1NlbGVjdGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgc2VsZWN0aW9uVHlwZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHJlb3JkZXJhYmxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgaGVhZGVySGVpZ2h0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS5oZWlnaHQnLF0gfSwgeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgY29sdW1uczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIG9mZnNldFg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBzb3J0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIHJlb3JkZXI6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICAgICAgcmVzaXplOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIHNlbGVjdDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgICAgICBjb2x1bW5Db250ZXh0bWVudTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgICAgICBoZWFkZXJXaWR0aDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUud2lkdGgnLF0gfV1cbiAgICB9O1xuICAgIHJldHVybiBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQ7XG59KCkpO1xuZXhwb3J0IHsgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50IH07XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5zb3J0QXNjZW5kaW5nSWNvbjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5zb3J0RGVzY2VuZGluZ0ljb247XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUuc2Nyb2xsYmFySDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5kZWFsc1dpdGhHcm91cDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS50YXJnZXRNYXJrZXJUZW1wbGF0ZTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS50YXJnZXRNYXJrZXJDb250ZXh0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLnNvcnRzO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLnNvcnRUeXBlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLmFsbFJvd3NTZWxlY3RlZDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5zZWxlY3Rpb25UeXBlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLnJlb3JkZXJhYmxlO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLmRyYWdFdmVudFRhcmdldDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5zb3J0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLnJlb3JkZXI7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUucmVzaXplO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLnNlbGVjdDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5jb2x1bW5Db250ZXh0bWVudTtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5fY29sdW1uc0J5UGluO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLl9jb2x1bW5Hcm91cFdpZHRocztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5faW5uZXJXaWR0aDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5fb2Zmc2V0WDtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5fY29sdW1ucztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgRGF0YVRhYmxlSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZS5faGVhZGVySGVpZ2h0O1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLl9zdHlsZUJ5R3JvdXA7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEYXRhVGFibGVIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3llZDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERhdGFUYWJsZUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUuY2Q7XG59XG4iXX0=